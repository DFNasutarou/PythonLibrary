{
  "adm": {
    "prefix": "adm",
    "body": [
      "# 0 <= x <= n 逆元リスト",
      "def invL(n, MOD): ",
      "  I = [0, 1]",
      "  for i in range(2, n + 1):",
      "    I.append(MOD - I[MOD % i] * (MOD // i) % MOD)",
      "  return I",
      "",
      "# アダマール変換",
      "def fwt(f):",
      "  n = len(f)",
      "  i = 1",
      "  while i < n:",
      "    for j in range(n):",
      "      if j & i == 0:",
      "        x, y = f[j], f[j | i]",
      "        f[j], f[j | i]  = x + y, x - y",
      "    i <<= 1",
      "",
      "# 実行",
      "def exe(L, MOD):",
      "  n = len(L)",
      "  # nは2べきじゃないとだめ",
      "  I = invL(n, MOD)",
      "  fwt(L)",
      "  # ここに処理を書く",
      "  proc(L)",
      "  fwt(L)",
      "  for i in range(n):",
      "    L[i] *= I[n]",
      "    L[i] %= MOD",
      "  return L",
      "",
      "# ここに処理を書く",
      "def proc(L):",
      "  pass",
      ""
    ],
    "description": "アダマール変換",
    "scope": "python"
  },
  "avl": {
    "prefix": "avl",
    "body": [
      "class AVL:",
      "  class Node:",
      "    def __init__(s, k, v):",
      "      s.k = k # key 一意",
      "      s.v = v # value 重複可",
      "      s.l = None # 小さいほう",
      "      s.r = None # 大きいほう",
      "      s.d = 1 # 深さ",
      "  def __init__(s):",
      "    s.x = None",
      "  def l_rot(s, z):",
      "    y = z.r",
      "    t = y.l",
      "    y.l, z.r = z, t",
      "    z.d = s.get_depth(z)",
      "    y.d = s.get_depth(y)",
      "    return y",
      "  def r_rot(s, z):",
      "    y = z.l",
      "    t = y.r",
      "    y.r, z.l = z, t",
      "    z.d = s.get_depth(z)",
      "    y.d = s.get_depth(y)",
      "    return y",
      "  def depth(s, node):",
      "    if not node: return 0",
      "    else: return node.d",
      "  def get_depth(s, node):",
      "    return 1 + max(s.depth(node.l), s.depth(node.r))",
      "  def balance(s, node):",
      "    return s.depth(node.l) - s.depth(node.r)",
      "  def rotate_l(s, node):",
      "    bal = s.balance(node)",
      "    if bal > 1:",
      "      if s.balance(node.l) >= 0:",
      "        node = s.r_rot(node)",
      "      else:",
      "        node.l = s.l_rot(node.l)",
      "        node = s.r_rot(node)",
      "    node.d = s.get_depth(node)",
      "    return node",
      "  def rotate_r(s, node):",
      "    bal = s.balance(node)",
      "    if bal < -1:",
      "      if s.balance(node.r) <= 0:",
      "        node = s.l_rot(node)",
      "      else:",
      "        node.r = s.r_rot(node.r)",
      "        node = s.l_rot(node)",
      "    node.d = s.get_depth(node)",
      "    return node",
      "  #挿入  ",
      "  def insert(s, k, v): ",
      "    s.x = s.insert_sub(s.x, k, v)",
      "  def insert_sub(s, node, k, v):",
      "    if not node: return s.Node(k, v)",
      "    elif node.k == k: return node",
      "    elif node.k > k: ",
      "      node.l = s.insert_sub(node.l, k, v)",
      "      return s.rotate_l(node)",
      "    else:",
      "      node.r = s.insert_sub(node.r, k, v)",
      "      return s.rotate_r(node)",
      "  #削除",
      "  def delete(s, k):",
      "    s.x = s.delete_sub(s.x, k)",
      "  def delete_sub(s, node, k):",
      "    if not node: return None",
      "    elif node.k == k:",
      "      if node.l is None: return node.r",
      "      else:",
      "        node.l = s.delete_max(node.l)",
      "        node.k = s.k",
      "        node.v = s.v",
      "        return s.rotate_l(node)",
      "    elif node.k > k: ",
      "      node.l = s.delete_sub(node.l, k)",
      "      return s.rotate_r(node)",
      "    else: ",
      "      node.r = s.delete_sub(node.r, k)",
      "      return s.rotate_l(node)",
      "  def delete_max(s, node):",
      "    if node.r == None:",
      "      s.k = node.k",
      "      s.v = node.v",
      "      return node.l",
      "    else:",
      "      node.r = s.delete_max(node.r)",
      "      return s.rotate_r(node)",
      "  #探索",
      "  def check(s, k):",
      "    return s.check_sub(k, s.x)",
      "  def check_sub(s, k, node):",
      "    if node == None: return False",
      "    if node.k == k: return True",
      "    if node.k > k: return s.check_sub(k, node.l)",
      "    else: return s.check_sub(k, node.r)",
      "  def getMax(s):",
      "    if not s.x: return None, None",
      "    return s.check_max_sub(s.x)",
      "  def check_max_sub(s, node):",
      "    if node.r: return s.check_max_sub(node.r)",
      "    else: return node.k, node.v",
      "  def getMin(s):",
      "    if not s.x: return None, None",
      "    return s.check_min_sub(s.x)",
      "  def check_min_sub(s, node):",
      "    if node.l: return s.check_min_sub(node.l)",
      "    else: return node.k, node.v",
      "  #表示",
      "  def print(s):",
      "    print(\"------------------------\")",
      "    s.print_sub(s.x)",
      "    print(\"------------------------\")",
      "  def print_sub(s, node):",
      "    if node:",
      "      s.print_sub(node.r)",
      "      print(\" \" * (s.x.d - node.d) + str(node.k) + \":\" + str(node.v))",
      "      s.print_sub(node.l)",
      "  #リスト作成",
      "  def makeKeyList(s, L):",
      "    N = len(L)",
      "    D = [[L[i], i, 0] for i in range(N)]",
      "    D.sort()",
      "    for i in range(N):",
      "      D[i][2] = i",
      "    D.sort(key = lambda x: x[1])",
      "    return [D[i][2] for i in range(N)]",
      ""
    ],
    "description": "avl木",
    "scope": "python"
  },
  "BIT": {
    "prefix": "BIT",
    "body": [
      "class BIT:",
      "  ini = 0",
      "  def __init__(s, num):",
      "    s.N = 1",
      "    while s.N <= num:",
      "      s.N *= 2",
      "    s.T = [s.ini] * s.N",
      "  def set(s, L):",
      "    for i in range(len(L)):",
      "      s.update(i, L[i])",
      "  def update(s, x, n): # xにnを加える",
      "    k = x + 1",
      "    s.T[k - 1] += n",
      "    k += k & -k",
      "    while k <= s.N:",
      "      s.T[k - 1] += n",
      "      k += k & -k",
      "  def getV(s, x): # xまでの和(x含む)",
      "    if x < 0: return 0",
      "    x += 1",
      "    ans = s.T[x - 1]",
      "    x -= x & -x",
      "    while x != 0:",
      "      ans += s.T[x - 1]",
      "      x -= x & -x",
      "    return ans",
      ""
    ],
    "description": "BIT",
    "scope": "python"
  },
  "bitall": {
    "prefix": "bitall",
    "body": [
      "n = (1 << M) - 1",
      "while n < (1 << N):",
      "  x = n & -n",
      "  y = n + x",
      "  n = ((n & ~y) // x >> 1) | y",
      ""
    ],
    "description": "説明",
    "scope": "python"
  },
  "CHT": {
    "prefix": "CHT",
    "body": [
      "class CHT:",
      "  # 最大値 を取得",
      "  def __init__(s):",
      "    s.L = []",
      "    s.cnt = 0",
      "  # ax + b の直線を追加",
      "  # aが昇順になるように追加すること",
      "  def add(s, a, b):",
      "    ab3 = [a, b]",
      "    while len(s.L) >= 2:",
      "      ab1 = s.L[-2]",
      "      ab2 = s.L[-1]",
      "      x1 = s.renritu(ab1, ab2)",
      "      x2 = s.renritu(ab2, ab3)",
      "      if x1 < x2: break",
      "      s.L.pop()",
      "    s.L.append(ab3)",
      "  # xの最大値を取得",
      "  # 前回チェックしたxより小さい値はチェックできない",
      "  def check(s, x):",
      "    a = s.func(x, s.cnt)",
      "    while s.cnt < len(s.L) - 1:",
      "      b = s.func(x, s.cnt + 1)",
      "      if a > b: break",
      "      s.cnt += 1",
      "      a = b",
      "    return a",
      "  def renritu(s, ab1, ab2):",
      "    a1, b1 = ab1",
      "    a2, b2 = ab2",
      "    return (b2 - b1) / (a1 - a2)",
      "  def func(s, x, n):",
      "    a, b = s.L[n]",
      "    return a * x + b",
      ""
    ],
    "description": "Convex-Hull Trick",
    "scope": "python"
  },
  "comb": {
    "prefix": "comb",
    "body": [
      "class comb():",
      "  F = [1, 1]",
      "  Fi = [1, 1]",
      "  I = [0, 1]",
      "  def __init__(self, num, mod):",
      "    self.MOD = mod",
      "    for i in range(2, num + 1):",
      "      self.F.append((self.F[-1] * i) % mod)",
      "      self.I.append(mod - self.I[mod % i] * (mod // i) % mod)",
      "      self.Fi.append(self.Fi[-1] * self.I[i] % mod)",
      "  def com(self, n, k):",
      "    if n < k: return 0",
      "    if n < 0 or k < 0: return 0",
      "    return self.F[n] * (self.Fi[k] * self.Fi[n - k] % self.MOD) % self.MOD",
      ""
    ],
    "description": "二項係数",
    "scope": "python"
  },
  "convmod": {
    "prefix": "convmod",
    "body": [
      "class Convolution:",
      "  def __init__(s, MOD):",
      "    s.MOD = MOD",
      "    s.PrimitiveRoot = s.primitive_root(MOD)",
      "    s._BIT_TABLE = [0] * 64",
      "    _BIT_HASH = 0x03F566ED27179461",
      "    for i in range(64):",
      "      s._BIT_TABLE[_BIT_HASH >> 58] = i",
      "      _BIT_HASH <<= 1",
      "      _BIT_HASH &= 0xFFFFFFFFFFFFFFFF",
      "",
      "  def convolution(s, a, b):",
      "    n, m = len(a), len(b)",
      "    if not n or not m: return []",
      "    if min(n, m) <= 60:",
      "      if n < m:",
      "        n, m = m, n",
      "        a, b = b, a",
      "      ans = [0] * (n + m - 1)",
      "      for i in range(n):",
      "        for j in range(m):",
      "          ans[i + j] = (ans[i + j] + a[i] * b[j]) % s.MOD",
      "      return ans",
      "    z = 1 << s.ceil_pow2(n + m - 1)",
      "    a = a + [0] * (z - n)",
      "    a = s.butterfly(a)",
      "    b = b + [0] * (z - m)",
      "    b = s.butterfly(b)",
      "    for i in range(z): a[i] = a[i] * b[i] % s.MOD",
      "    a = s.butterfly_inv(a)",
      "    iz = pow(z, s.MOD - 2, s.MOD)",
      "    for i in range(n + m - 1): a[i] = a[i] * iz % s.MOD",
      "    return a[:n + m - 1]",
      "",
      "  def butterfly(s, a):",
      "    g = s.PrimitiveRoot",
      "    n = len(a)",
      "    h = s.ceil_pow2(n)",
      "",
      "    first = True",
      "    sum_e = [0] * 30",
      "    if first:",
      "      first = False",
      "      es, ies = [0] * 30, [0] * 30",
      "      cnt2 = s.bsf(s.MOD - 1)",
      "      e = pow(g, ((s.MOD - 1) >> cnt2), s.MOD)",
      "      ie = pow(e, s.MOD - 2, s.MOD)",
      "      for i in range(cnt2, 1, -1):",
      "        es[i - 2] = e",
      "        ies[i - 2] = ie",
      "        e = e * e % s.MOD",
      "        ie = ie * ie % s.MOD",
      "      now = 1",
      "      for i in range(cnt2 - 2):",
      "        sum_e[i] = es[i] * now % s.MOD",
      "        now = now * ies[i] % s.MOD",
      "    for ph in range(1, h + 1):",
      "      w, p = 1 << (ph - 1), 1 << (h - ph)",
      "      now = 1",
      "      for ss in range(w):",
      "        offset = ss << (h - ph + 1)",
      "        for i in range(p):",
      "          l = a[i + offset]",
      "          r = a[i + offset + p] * now % s.MOD",
      "          a[i + offset] = (l + r) % s.MOD",
      "          a[i + offset + p] = (l - r) % s.MOD",
      "        now = now * sum_e[s.bsf(~ss)] % s.MOD",
      "    return a",
      "",
      "  def butterfly_inv(s, a):",
      "    g = s.PrimitiveRoot",
      "    n = len(a)",
      "    h = s.ceil_pow2(n)",
      "",
      "    first = True",
      "    sum_ie = [0] * 30",
      "    if first:",
      "      first = False",
      "      es, ies = [0] * 30, [0] * 30",
      "      cnt2 = s.bsf(s.MOD - 1)",
      "      e = pow(g, ((s.MOD - 1) >> cnt2), s.MOD)",
      "      ie = pow(e, s.MOD - 2, s.MOD)",
      "      for i in range(cnt2, 1, -1):",
      "        es[i - 2] = e",
      "        ies[i - 2] = ie",
      "        e = e * e % s.MOD",
      "        ie = ie * ie % s.MOD",
      "      now = 1",
      "      for i in range(cnt2 - 2):",
      "        sum_ie[i] = ies[i] * now % s.MOD",
      "        now = now * es[i] % s.MOD",
      "    for ph in range(h, 0, -1):",
      "      w, p = 1 << (ph - 1), 1 << (h - ph)",
      "      inow = 1",
      "      for ss in range(w):",
      "        offset = ss << (h - ph + 1)",
      "        for i in range(p):",
      "          l = a[i + offset]",
      "          r = a[i + offset + p]",
      "          a[i + offset] = (l + r) % s.MOD",
      "          a[i + offset + p] = (s.MOD + l - r) * inow % s.MOD",
      "        inow = inow * sum_ie[s.bsf(~ss)] % s.MOD",
      "    return a",
      "",
      "  def ceil_pow2(s, n):",
      "    x = 0",
      "    while (1 << x) < n: x += 1",
      "    return x",
      "",
      "  def bsf(s, n):",
      "    if n == 0: return 64",
      "    x = n",
      "    y = x & -x",
      "    i = ((y * 0x03F566ED27179461) & 0xFFFFFFFFFFFFFFFF) >> 58",
      "    return s._BIT_TABLE[i]",
      "",
      "  def prime(s, x):",
      "    L, U = [], []",
      "    i = 1",
      "    while i * i <= x:",
      "      if x % i == 0:",
      "        L.append(i)",
      "        if i != x // i:",
      "          U.append(x // i)",
      "      i += 1",
      "    return L + U[::-1]",
      "",
      "  def primitive_root(s, x):",
      "    L = s.prime(x - 1)",
      "    a, i = 2, 0",
      "    k = len(L) - 1",
      "    while i != k:",
      "      if pow(a, L[i], x) == 1:",
      "        a += 1",
      "        i = 0",
      "      else:",
      "        i += 1",
      "    return a",
      ""
    ],
    "description": "畳み込みMOD",
    "scope": "python"
  },
  "convolve": {
    "prefix": "convolve_ll",
    "body": [
      "import numpy as np",
      "",
      "def convolve(f, g):",
      "    \"\"\"多項式 f, g の積を計算する。",
      "",
      "    Parameters",
      "    ----------",
      "    f : np.ndarray (int64)",
      "        f[i] に、x^i の係数が入っている",
      "",
      "    g : np.ndarray (int64)",
      "        g[i] に、x^i の係数が入っている",
      "",
      "",
      "    Returns",
      "    -------",
      "    h : np.ndarray",
      "        f,g の積",
      "    \"\"\"",
      "    # h の長さ以上の n=2^k を計算",
      "    fft_len = 1",
      "    while 2 * fft_len < len(f) + len(g) - 1:",
      "        fft_len *= 2",
      "    fft_len *= 2",
      "",
      "    # フーリエ変換",
      "    Ff = np.fft.rfft(f, fft_len)",
      "    Fg = np.fft.rfft(g, fft_len)",
      "",
      "    # 各点積",
      "    Fh = Ff * Fg",
      "",
      "    # フーリエ逆変換",
      "    h = np.fft.irfft(Fh, fft_len)",
      "",
      "    # 小数になっているので、整数にまるめる",
      "    h = np.rint(h).astype(np.int64)",
      "",
      "    return h[:len(f) + len(g) - 1]",
      "",
      ""
    ],
    "description": "畳み込み",
    "scope": "python"
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "import heapq",
      "pop = heapq.heappop",
      "push = heapq.heappush",
      "",
      "class Dijkstra:",
      "  R = {}",
      "  def __init__(s, N):",
      "    s.N = N",
      "",
      "  def add(s, a, b, x):",
      "    if a not in s.R: s.R[a] = {b: x}",
      "    elif b not in s.R[a]:s.R[a][b] = x",
      "    else: s.R[a][b] = x",
      "",
      "  def exe(s, start):",
      "    D = [-1] * s.N ",
      "    q  = []",
      "    push(q, (0, start))",
      "    cnt = 0",
      "    while cnt < s.N:",
      "      if q == []:",
      "        break",
      "      d, x = pop(q)",
      "      if D[x] != -1: continue",
      "      D[x] = d",
      "      cnt += 1",
      "      for i in s.R[x]:",
      "        if D[i] != -1: continue",
      "        j = s.R[x][i]",
      "        push(q, (d + j, i))",
      "    return D",
      ""
    ],
    "description": "ダイクストラ法",
    "scope": "python"
  },
  "divhoujo": {
    "prefix": "divhoujo",
    "body": [
      "def exe(x):",
      "  ans = 0",
      "  return ans % MOD",
      "",
      "import math",
      "def divisor(n):",
      "  if n == 1: return [1]",
      "  L, R = [1], [n]",
      "  last = math.floor(n ** 0.5)",
      "  for i in range(2, last + 1):",
      "    if n % i == 0:",
      "      L.append(i)",
      "      if i != n // i:",
      "        R.append(n // i)",
      "  return L + R[::-1]",
      "",
      "def divhoujo(D):",
      "  R = {}",
      "  ans = 0",
      "  for d in D:",
      "    p = exe(d)",
      "    for x in divisor(d)[:-1]:",
      "      p -= R[x]",
      "      p %= MOD",
      "    R[d] = p",
      "    ans += p",
      "    ans %= MOD",
      "  return ans",
      ""
    ],
    "description": "約数包除",
    "scope": "python"
  },
  "divisor": {
    "prefix": "divisor",
    "body": [
      "import math",
      "def divisor(n):",
      "  L, R = [1], [n]",
      "  last = math.floor(n ** 0.5)",
      "  for i in range(2, last + 1):",
      "    if n % i == 0:",
      "      L.append(i)",
      "      if i != n // i:",
      "        R.append(n // i)",
      "  return L + R[::-1]",
      ""
    ],
    "description": "約数",
    "scope": "python"
  },
  "gridMan": {
    "prefix": "grid",
    "body": [
      "class gridMan:",
      "  def __init__(s, L):",
      "    s.L = L",
      "    s.H = len(s.L)",
      "    s.W = len(s.L[0])",
      "  def makeWall(s, x = -2):",
      "    w = len(s.L[0]) + 2",
      "    s.L = [[x] * w] + [[x] + i + [x] for i in s.L] + [[x] * w]",
      "  def dist(s, S): #Sから上下左右に進んで何手かかるかのリスト　および　最大値",
      "    T = [[-1] * s.W for _ in range(s.H)]",
      "    List = [[S[0], S[1]]]",
      "    T[S[0]][S[1]] = 0",
      "    k = 0",
      "    while List != []:",
      "      newList = []",
      "      for h, w in List:",
      "        k = T[h][w]",
      "        for x, y in [[h - 1, w], [h + 1, w], [h, w - 1], [h, w + 1]]:",
      "          if not (0 <= x < s.H): continue",
      "          if not (0 <= y < s.W): continue",
      "          if s.L[x + 1][y + 1] >= 0 and T[x][y] == -1:",
      "            newList.append([x, y])",
      "            T[x][y] = k + 1",
      "      List = newList",
      "    return T, k",
      "  ",
      ""
    ],
    "description": "グリッド",
    "scope": "python"
  },
  "gyoretu": {
    "prefix": "gyoretu",
    "body": [
      "# 行列累乗",
      "# mat_pow(行列, 累乗)",
      "# MOD を設定しておく",
      "MOD = 998244353",
      "def mat_mul(a, b) :",
      "    I, J, K = len(a), len(b[0]), len(b)",
      "    c = [[0] * J for _ in range(I)]",
      "    for i in range(I) :",
      "        for j in range(J) :",
      "            for k in range(K) :",
      "                c[i][j] += a[i][k] * b[k][j]",
      "            c[i][j] %= MOD",
      "    return c",
      "",
      "def mat_pow(x, n):",
      "    y = [[0] * len(x) for _ in range(len(x))]",
      "    for i in range(len(x)):",
      "        y[i][i] = 1",
      "    while n > 0:",
      "        if n & 1:",
      "            y = mat_mul(x, y)",
      "        x = mat_mul(x, x)",
      "        n >>= 1",
      "    return y",
      ""
    ],
    "description": "行列累乗",
    "scope": "python"
  },
  "hakidasi": {
    "prefix": "hakidasi",
    "body": [
      "def hakidasi(L):",
      "  n = len(bin(max(L))) - 2",
      "  k, end = 0, len(L)",
      "  for i in range(n - 1, -1, -1):",
      "    for j in range(k, end):",
      "      if (L[j] >> i) & 1:",
      "        L[k], L[j] = L[j], L[k]",
      "        break",
      "    else:",
      "      continue",
      "    k += 1",
      "    for j in range(k, end):",
      "      if (L[j] >> i) & 1:",
      "        L[j] ^= L[k - 1]",
      "  return L",
      ""
    ],
    "description": "掃き出し法",
    "scope": "python"
  },
  "heapq": {
    "prefix": "heapq",
    "body": [
      "import heapq",
      "pop = heapq.heappop",
      "push = heapq.heappush",
      "q  = []",
      ""
    ],
    "description": "ヒープ",
    "scope": "python"
  },
  "input": {
    "prefix": "input",
    "body": [
      "import sys",
      "input = sys.stdin.readline",
      ""
    ],
    "description": "入力が重いとき",
    "scope": "python"
  },
  "Inverse": {
    "prefix": "inv",
    "body": [
      "class Inv:",
      "  def __init__(s, mod):",
      "    s.MOD = mod",
      "  def modpow(s, a, n):",
      "    res = 1",
      "    while n > 0:",
      "      if n & 1:",
      "        res = res * a % s.MOD",
      "      a = a * a % s.MOD",
      "      n >>= 1",
      "    return res",
      "  def invx(s, a):",
      "    return s.modpow(a, s.MOD - 2)",
      "  def invpowL(s, a, n): # a^-x (0 <= x <= n)リスト",
      "    ia = s.invx(a)",
      "    L = [1] * (n + 1)",
      "    for i in range(1, n + 1):",
      "      L[i] = L[i - 1] * ia % s.MOD",
      "    return L",
      "  def invL(s, n): # 0 <= x <= n 逆元リスト",
      "    I = [0, 1]",
      "    for i in range(2, n + 1):",
      "      I.append(s.MOD - I[s.MOD % i] * (s.MOD // i) % s.MOD)",
      "    return I",
      ""
    ],
    "description": "逆元",
    "scope": "python"
  },
  "kika": {
    "prefix": "kika",
    "body": [
      "def turn(D):",
      "  return [list(x) for x in zip(*D)][::-1]",
      "def trim(D):",
      "  ng = \".\"",
      "  for _ in range(4):",
      "    for i in range(len(D)):",
      "      t = list(set(D[i]))",
      "      if len(t) != 1 or t[0] != ng:",
      "        break",
      "    D = D[i:]",
      "    D = turn(D)",
      "  return D",
      ""
    ],
    "description": "幾何",
    "scope": "python"
  },
  "kruskal": {
    "prefix": "kruskal",
    "body": [
      "class Union:",
      "  def __init__(s, num):",
      "    s.T = [-1 for i in range(num)]",
      " ",
      "  def root(s, x):",
      "    if s.T[x] < 0: return x, -s.T[x]",
      "    t, k = s.root(s.T[x])",
      "    s.T[x] = t",
      "    return t, k",
      " ",
      "  def merge(s, x, y):",
      "    an, am = s.root(x)",
      "    bn, bm = s.root(y)",
      "    if an == bn: return False",
      "    if am < bm: an, bn  = bn, an",
      "    s.T[an] += s.T[bn]",
      "    s.T[bn] = an",
      "    return True",
      " ",
      "  def size(s, x):",
      "    return s.root(x)[1]",
      "",
      "  def same(s, x, y):",
      "    return s.root(x)[0] == s.root(y)[0]",
      "",
      "class Kruskal:",
      "  def __init__(s, N):",
      "    s.N = N",
      "    s.U = Union(N)",
      "    s.C = []",
      "",
      "  def add(s, a, b, x):",
      "    s.C.append([x, a, b, len(s.C)])",
      "",
      "  def exe(s):",
      "    s.C.sort()",
      "    ans = []",
      "    for i in range(len(s.C)):",
      "      x, a, b, n = s.C[i]",
      "      if s.U.merge(a, b):",
      "        ans.append([n, a, b, x])",
      "        s.U.merge(a, b)",
      "    return ans",
      ""
    ],
    "description": "クラスカル法",
    "scope": "python"
  },
  "kyori": {
    "prefix": "kyori",
    "body": [
      "def edist(a, b):",
      "  x = (a[0] - b[0]) ** 2",
      "  y = (a[1] - b[1]) ** 2",
      "  return (x + y) ** (1 / 2)",
      "",
      "def mdist(a, b):",
      "  x = abs(a[0] - b[0])",
      "  y = abs(a[1] - b[1])",
      "  return x + y",
      "",
      "def cdist(a, b):",
      "  ma = abs(a[0] - b[0])",
      "  ma = max(ma, abs(a[1] - b[1]))",
      "  return ma",
      ""
    ],
    "description": "距離",
    "scope": "python"
  },
  "lazyseg": {
    "prefix": "lazyseg",
    "body": [
      "class lazySegTree:",
      "  #遅延評価セグメント木",
      "  def __init__(s, op, e, mapping, composition, id, v):",
      "    if type(v) is int: v = [e()] * v",
      "    s._n = len(v)",
      "    s.log = s.ceil_pow2(s._n)",
      "    s.size = 1 << s.log",
      "    s.d = [e()] * (2 * s.size)",
      "    s.lz = [id()] * s.size",
      "    s.e = e",
      "    s.op = op",
      "    s.mapping = mapping",
      "    s.composition = composition",
      "    s.id = id",
      "    for i in range(s._n): s.d[s.size + i] = v[i]",
      "    for i in range(s.size - 1, 0, -1): s.update(i)",
      "  ",
      "  # 1点更新",
      "  def set(s, p, x):",
      "    p += s.size",
      "    for i in range(s.log, 0, -1): s.push(p >> i)",
      "    s.d[p] = x",
      "    for i in range(1, s.log + 1): s.update(p >> i)",
      " ",
      "  # 1点取得",
      "  def get(s, p):",
      "    p += s.size",
      "    for i in range(s.log, 0, -1): s.push(p >> i)",
      "    return s.d[p]",
      " ",
      "  # 区間演算",
      "  def prod(s, l, r):",
      "    if l == r: return s.e()",
      "    l += s.size",
      "    r += s.size",
      "    for i in range(s.log, 0, -1):",
      "      if (((l >> i) << i) != l): s.push(l >> i)",
      "      if (((r >> i) << i) != r): s.push(r >> i)",
      "    sml, smr = s.e(), s.e()",
      "    while (l < r):",
      "      if l & 1: ",
      "        sml = s.op(sml, s.d[l])",
      "        l += 1",
      "      if r & 1:",
      "        r -= 1",
      "        smr = s.op(s.d[r], smr)",
      "      l >>= 1",
      "      r >>= 1",
      "    return s.op(sml, smr)",
      " ",
      "  # 全体演算",
      "  def all_prod(s): return s.d[1]",
      " ",
      "  # 1点写像",
      "  def apply(s, p, f):",
      "    p += s.size",
      "    for i in range(s.log, 0, -1): s.push(p >> i)",
      "    s.d[p] = s.mapping(f, s.d[p])",
      "    for i in range(1, s.log + 1): s.update(p >> i)",
      " ",
      "  # 区間写像",
      "  def apply(s, l, r, f):",
      "    if l == r: return",
      "    l += s.size",
      "    r += s.size",
      "    for i in range(s.log, 0, -1):",
      "      if (((l >> i) << i) != l): s.push(l >> i)",
      "      if (((r >> i) << i) != r): s.push((r - 1) >> i)",
      "    l2, r2 = l, r",
      "    while l < r:",
      "      if l & 1: ",
      "        sml = s.all_apply(l, f)",
      "        l += 1",
      "      if r & 1:",
      "        r -= 1",
      "        smr = s.all_apply(r, f)",
      "      l >>= 1",
      "      r >>= 1",
      "    l, r = l2, r2",
      "    for i in range(1, s.log + 1):",
      "      if (((l >> i) << i) != l): s.update(l >> i)",
      "      if (((r >> i) << i) != r): s.update((r - 1) >> i)",
      "   ",
      "  # L固定時の最長区間のR",
      "  def max_right(s, l, g):",
      "    if l == s._n: return s._n",
      "    l += s.size",
      "    for i in range(s.log, 0, -1): s.push(l >> i)",
      "    sm = s.e()",
      "    while True:",
      "      while (l % 2 == 0): l >>= 1",
      "      if not g(s.op(sm, s.d[l])):",
      "        while l < s.size:",
      "          s.push(l)",
      "          l = 2 * l",
      "          if g(s.op(sm, s.d[l])):",
      "            sm = s.op(sm, s.d[l])",
      "            l += 1",
      "        return l - s.size",
      "      sm = s.op(sm, s.d[l])",
      "      l += 1",
      "      if (l & -l) == l: break",
      "    return s._n",
      " ",
      "  # R固定時の最長区間のL",
      "  def min_left(s, r, g):",
      "    if r == 0: return 0",
      "    r += s.size",
      "    for i in range(s.log, 0, -1): s.push((r - 1) >> i)",
      "    sm = s.e()",
      "    while True:",
      "      r -= 1",
      "      while r > 1 and (r % 2): r >>= 1",
      "      if not g(s.op(s.d[r], sm)):",
      "        while r < s.size:",
      "          s.push(r)",
      "          r = 2 * r + 1",
      "          if g(s.op(s.d[r], sm)):",
      "            sm = s.op(s.d[r], sm)",
      "            r -= 1",
      "        return r + 1 - s.size",
      "      sm = s.op(s.d[r], sm)",
      "      if (r & - r) == r: break",
      "    return 0",
      " ",
      "  def update(s, k): s.d[k] = s.op(s.d[2 * k], s.d[2 * k + 1])",
      "  def all_apply(s, k, f):",
      "    s.d[k] = s.mapping(f, s.d[k])",
      "    if k < s.size: s.lz[k] = s.composition(f, s.lz[k])",
      "  def push(s, k):",
      "    s.all_apply(2 * k, s.lz[k])",
      "    s.all_apply(2 * k + 1, s.lz[k])",
      "    s.lz[k] = s.id()",
      "  def ceil_pow2(s, n):",
      "    x = 0",
      "    while (1 << x) < n: x += 1",
      "    return x",
      "  def print(s): #デバッグ用",
      "    ans = []",
      "    for i in range(s._n):",
      "      ans.add(s.get(i))",
      "    print(*ans)",
      "",
      "'''",
      "作用付きモノイド (X, ○), (M, ☆), □",
      "X □ M → X",
      "a, b, e ∈ X, f, g, d ∈ M",
      "a ○ e = a, f ☆ d = f, a □ d = a ?",
      "(a ○ b) □ f = (a □ f) ○ (b □ f)",
      "(a □ f) □ g = a □ (f ☆ g)",
      "'''",
      "# モノイドXの単位元",
      "# return a・e = a となる e",
      "def e():",
      "  return 0",
      "",
      "# モノイドXの演算",
      "# return a・b",
      "def op(a, b):",
      "  return 0",
      "",
      "# XにMを作用させた結果",
      "# return a・f",
      "def mapping(f, a):",
      "  return 0",
      "",
      "# モノイドMの演算",
      "# return f・g",
      "def composition(f, g):",
      "  return 0",
      "",
      "# モノイドMの単位元",
      "# return f・id = id となる id",
      "def id():",
      "  return 0",
      "",
      "seg = lazySegTree(op, e, mapping, composition, id, a)",
      ""
    ],
    "description": "遅延評価セグメント木",
    "scope": "python"
  },
  "list": {
    "prefix": "li",
    "body": [
      "list(map(int, input().split()))",
      ""
    ],
    "description": "リスト",
    "scope": "python"
  },
  "listfor": {
    "prefix": "listfor",
    "body": [
      "[list(map(int, input().split())) for _ in range(N)]",
      ""
    ],
    "description": "複数リスト",
    "scope": "python"
  },
  "math": {
    "prefix": "math",
    "body": [
      "# 逆元",
      "# O(log m)",
      "def inv_mod(x, m):",
      "  # フェルマーの小定理を利用",
      "  return pow(x, m - 2, m)",
      "",
      "# 中国剰余定理",
      "# mod取った値とmodのリストから元の値を復元する",
      "# O(n log lcm(m[i]))",
      "def crt(r, m):",
      "  n = len(r)",
      "  r0, m0 = 0, 1",
      "  for i in range(n):",
      "    r1 = r[i] % m[i]",
      "    m1 = m[i]",
      "    if m0 < m1:",
      "      r0, r1 = r1, r0",
      "      m0, m1 = m1, m0",
      "    if m0 % m1 == 0:",
      "      # 解が存在しない場合は0,0",
      "      if r0 % m1 != r1: return (0, 0)",
      "      continue",
      "    g, im = inv_gcd(m0, m1)",
      "    u1 = m1 // g",
      "    # 解が存在しない場合は0,0",
      "    if ((r1 - r0) % g): return (0, 0)",
      "    x = (r1 - r0) // g % u1 * im % u1",
      "    r0 += x * m0",
      "    m0 *= u1",
      "    if r0 < 0: r0 += m0",
      "  # r0 = ans % m0",
      "  # n = 0 の場合 (0, 1)",
      "  # 解がない場合 (0, 0)",
      "  return (r0, m0)",
      "",
      "# (a * i + b)/m (0 <= i <= n-1) の和",
      "# O(log(n + m + a + b))",
      "def floor_sum(n, m, a, b):",
      "  ans = 0",
      "  if a >= m:",
      "    ans += (n - 1) * n * (a // m) // 2",
      "    a %= m",
      "  if b >= m:",
      "    ans += n * (b // m)",
      "    b %= m",
      "  y_max = (a * n + b) // m",
      "  x_max = y_max * m - b",
      "  if y_max == 0: return ans",
      "  ans += (n - (x_max + a - 1) // a) * y_max",
      "  ans += floor_sum(y_max, a, m, (a - x_max % a) % a)",
      "  return ans",
      "",
      "# gcdと逆元",
      "def inv_gcd(a, b):",
      "  a = a % b",
      "  if a == 0: return (b, 0)",
      "  s, t = b, a",
      "  m0, m1 = 0, 1",
      "  while t:",
      "    u = s // t",
      "    s -= t * u",
      "    m0 -= m1 * u",
      "    s, t = t, s",
      "    m0, m1 = m1, m0",
      "  if m0 < 0: m0 += b // s",
      "  return (s, m0)",
      ""
    ],
    "description": "数学",
    "scope": "python"
  },
  "maxFlow": {
    "prefix": "flow",
    "body": [
      "NUMERIC_LIMITS = 10 ** 18",
      "import queue",
      "class maxFlow:",
      "  class edge:",
      "    def __init__(s, frm, to, cap, flow):",
      "      s.frm, s.to = frm, to",
      "      s.cap, s.flow = cap, flow",
      "",
      "  def __init__(s, n):",
      "    s._n = n",
      "    s.g = [[] for _ in range(n)]",
      "    s.pos = []",
      "",
      "  def add_edge(s, frm, to, cap):",
      "    m = len(s.pos)",
      "    s.pos.append([frm, len(s.g[frm])])",
      "    s.g[frm].append(s._edge(to, len(s.g[to]), cap))",
      "    s.g[to].append(s._edge(frm,len(s.g[frm]) - 1, 0))",
      "    return m",
      "",
      "  def get_edge(s, i):",
      "    m = len(s.pos)",
      "    _e = s.g[s.pos[i][0]][s.pos[i][1]]",
      "    _re = s.g[_e.to][_e.rev]",
      "    return s.edge(s.pos[i][0], _e.to, _e.cap + _re.cap, _re.cap)",
      "",
      "  def edges(s):",
      "    m = len(s.pos)",
      "    result = []",
      "    for i in range(m):",
      "      result.append(s.get_edge(i))",
      "    return result",
      "",
      "  def change_edge(s, i, new_cap, new_flow):",
      "    m = len(s.pos)",
      "    _e = s.g[s.pos[i].to][s.pos[i].rev]",
      "    _re = s.g[_e.to][_e.rev]",
      "    _e.cap = new_cap - new_flow",
      "    _re.cap = new_flow",
      "",
      "  def flow(self, s, t, flow_limit = NUMERIC_LIMITS):",
      "    level = [0] * self._n",
      "    iter = [0] * self._n ",
      "",
      "    def bfs():",
      "      for i in range(self._n):",
      "        level[i] = -1",
      "      level[s] = 0",
      "      que = queue.Queue()",
      "      que.put(s)",
      "      while not que.empty():",
      "        v = que.get()",
      "        for e in self.g[v]:",
      "           if e.cap == 0 or level[e.to] >= 0: continue",
      "           level[e.to] = level[v] + 1",
      "           if e.to == t: return",
      "           que.put(e.to)",
      "    def dfs(v, up):",
      "      V, UP = v, up",
      "      L = [(v, up)]",
      "      R = {}",
      "      RES = {}",
      "      while L:",
      "        v, up = L.pop()",
      "        if v == s:",
      "          R[v, up] = up",
      "          continue",
      "        level_v = level[v]",
      "        if (v, up) not in RES:",
      "          res, start = 0, iter[v]",
      "        else:",
      "          res, start = RES[v, up]",
      "        flag = True",
      "        for i in range(start, len(self.g[v])):",
      "          e = self.g[v][i]",
      "          if level_v <= level[e.to] or self.g[e.to][e.rev].cap == 0: continue",
      "          first, second = e.to, min(up - res, self.g[e.to][e.rev].cap)",
      "          if (first, second) not in R or R[first, second] == None:",
      "            L.append((v, up))",
      "            L.append((first, second))",
      "            RES[v, up] = (res, i)",
      "            flag = False",
      "            break",
      "          else:",
      "            d = R[first, second]",
      "            R[first, second] = None",
      "            if d <= 0: continue",
      "            self.g[v][i].cap += d",
      "            self.g[e.to][e.rev].cap -= d",
      "            res += d",
      "            if res == up: break          ",
      "        if flag:",
      "          R[v, up] = res",
      "      return R[V, UP]",
      "    #再起あり",
      "    def dfsold(this, v, up):",
      "      if v == s: return up",
      "      res = 0",
      "      level_v = level[v]",
      "      for i in range(iter[v], len(self.g[v])):",
      "        e = self.g[v][i]",
      "        if level_v <= level[e.to] or self.g[e.to][e.rev].cap == 0: continue",
      "        d = this(this, e.to, min(up - res, self.g[e.to][e.rev].cap))",
      "        if d <= 0: continue",
      "        self.g[v][i].cap += d",
      "        self.g[e.to][e.rev].cap -= d",
      "        res += d",
      "        if res == up: break",
      "      return res",
      "",
      "    flow = 0",
      "    while flow < flow_limit:",
      "      bfs()",
      "      if level[t] == -1: break",
      "      for i in range(self._n): iter[i]",
      "      while flow < flow_limit:",
      "        f = dfs(t, flow_limit - flow)",
      "        if not f: break",
      "        flow += f",
      "    return flow",
      "",
      "  def min_cut(self, s):",
      "    visited = [False] * self._n",
      "    que = queue.Queue()",
      "    que.put(s)",
      "    while not que.empty():",
      "      p = que.get()",
      "      visited[p] = True",
      "      for e in self.g[p]:",
      "        if e.cap and not visited[e.to]:",
      "          visited[e.to] = True",
      "          que.put(e.to)",
      "    return visited",
      "",
      "  class _edge:",
      "    def __init__(s, to, rev, cap):",
      "      s.to, s.rev = to, rev",
      "      s.cap = cap",
      ""
    ],
    "description": "最大流",
    "scope": "python"
  },
  "mincost": {
    "prefix": "mincost",
    "body": [
      "import heapq",
      "NUMERIC_LIMITS = 10 ** 18",
      "",
      "class mcf_graph:",
      "  def __init__ (s, n):",
      "    s._n = n",
      "    s.g = [[] for _ in range(n)]",
      "    s.pos = []",
      "",
      "  def add_edge(s, frm, to, cap, cost):",
      "    m = len(s.pos)",
      "    s.pos.append([frm, len(s.g[frm])])",
      "    s.g[frm].append(s._edge(to, len(s.g[to]), cap, cost))",
      "    s.g[to].append(s._edge(frm, len(s.g[frm]) - 1, 0, -cost))",
      "    return m",
      "",
      "  class edge:",
      "    __slots__ = \"frm\", \"to\", \"cap\", \"flow\", \"cost\"",
      "    def __init__(s, frm, to, cap, flow, cost):",
      "      s.frm, s.to = frm, to",
      "      s.cap, s.flow, s.cost = cap, flow, cost",
      "",
      "  def get_edge(s, i):",
      "    _e = s.g[s.pos[i][0]][s.pos[i][1]]",
      "    _re = s.g[_e.to][_e.rev]",
      "    return s.edge(s.pos[i][0], _e.to, _e.cap + _re.cap, _re.cap, _e.cost)",
      "",
      "  def edges(s):",
      "    for i in range(len(s.pos)):",
      "      yield s.get_edge(i)",
      "",
      "  def flow(self, s, t, flow_limit = NUMERIC_LIMITS):",
      "    return self.slope(s, t, flow_limit)[-1]",
      "",
      "  def dual_ref(self, s, t):",
      "    #priority_queueの代わり",
      "    push = heapq.heappush",
      "    pop = heapq.heappop",
      "",
      "    dist = [NUMERIC_LIMITS] * self._n",
      "    self.pv = [-1] * self._n",
      "    self.pe = [-1] * self._n",
      "    vis = [False] * self._n",
      "    que = []",
      "    dist[s] = 0",
      "    push(que, (0, s))",
      "    while que:",
      "      k, v = pop(que)",
      "      if vis[v]: continue",
      "      vis[v] = True",
      "      if v == t: break",
      "      for i in range(len(self.g[v])):",
      "        e = self.g[v][i]",
      "        if vis[e.to] or not e.cap: continue",
      "        cost = e.cost - self.dual[e.to] + self.dual[v]",
      "        if dist[e.to] - dist[v] > cost:",
      "          dist[e.to] = dist[v] + cost",
      "          self.pv[e.to] = v",
      "          self.pe[e.to] = i",
      "          push(que,(dist[e.to], e.to))",
      "    if not vis[t]: return False",
      "    for v in range(self._n):",
      "      if not vis[v]: continue",
      "      self.dual[v] -= dist[t] - dist[v]",
      "    return True",
      "",
      "  def slope(self, s, t, flow_limit = NUMERIC_LIMITS):",
      "    self.dual = [0] * self._n",
      "  ",
      "    flow = 0",
      "    cost, prev_cost = 0, -1",
      "    result = [(flow,cost)]",
      "    while flow < flow_limit:",
      "      if not self.dual_ref(s, t): break",
      "      c = flow_limit - flow",
      "      v = t",
      "      while v != s:",
      "        c = min(c, self.g[self.pv[v]][self.pe[v]].cap)",
      "        v = self.pv[v]",
      "      v = t",
      "      while v != s:",
      "        e = self.g[self.pv[v]][self.pe[v]]",
      "        e.cap -= c",
      "        self.g[v][e.rev].cap += c",
      "        v = self.pv[v]",
      "      d = -self.dual[s]",
      "      flow += c",
      "      cost += c * d",
      "      if prev_cost == d:",
      "        result.pop()",
      "      result.append((flow, cost))",
      "      prev_cost = cost",
      "    return result",
      "",
      "  class _edge:",
      "    __slots__ = \"to\", \"rev\", \"cap\", \"cost\"",
      "    def __init__(s, to, rev, cap, cost):",
      "      s.to, s.rev = to, rev",
      "      s.cap, s.cost = cap, cost",
      ""
    ],
    "description": "最小費用流",
    "scope": "python"
  },
  "mo": {
    "prefix": "mo",
    "body": [
      "class Mo:",
      "  def __init__(s, N, Query):",
      "    s.N = N",
      "    s.Query = Query",
      "    s.Q = len(Query)",
      "    n = int(N ** (1 / 2))",
      "    B = [[] for _ in range(-(-N // n))]",
      "    for que in query:",
      "      t = que[0]",
      "      p = (t - 1) // n",
      "      B[p].append(que + [i])",
      "      i += 1",
      "    for i in range(len(B)):",
      "      B[i].sort(key = lambda x:x[1])",
      "      if i % 2:",
      "        B[i].reverse()",
      "    s.ini()",
      "",
      "    for b in B:",
      "      for x, y, i in b:",
      "        if s.l > x:",
      "          for n in range(s.l - x):",
      "            s.l_minus()",
      "        if s.r > y:",
      "          for j in range(s.r - y):",
      "            s.r_minus()",
      "        if s.r < y:",
      "          for j in range(y - s.r):",
      "            s.r_plus()",
      "        if s.l < x:",
      "          for j in range(x - s.l):",
      "            s.l_plus()",
      "        s.anser(i)",
      "    return s.Ans",
      "  def anser(s, i):",
      "    s.Ans[i] = s.ans",
      "  def ini(s):",
      "    s.l, s.r = 1, 1",
      "    s.Ans = [0] * len(s.Q)",
      "    s.ans",
      "    pass",
      "  def l_plus(s):",
      "    pass",
      "  def l_minus(s):",
      "    pass",
      "  def r_plus(s):",
      "    pass",
      "  def r_minus(s):",
      "    pass",
      ""
    ],
    "description": "moアルゴリズム",
    "scope": "python"
  },
  "nibutan": {
    "prefix": "nibutan",
    "body": [
      "def nibutan(L, n):",
      "  #if L[-1] < n:",
      "  #  return len(L)",
      "  ok = 0",
      "  ng = len(L)",
      "  while abs(ok - ng) > 1:",
      "    mid = (ok + ng) // 2",
      "    if L[mid] <= n:",
      "      ok = mid",
      "    else:",
      "      ng = mid",
      "  return ok",
      ""
    ],
    "description": "二分探索",
    "scope": "python"
  },
  "period": {
    "prefix": "period",
    "body": [
      "def period(L, K, x = 0):",
      "  N = len(L)",
      "  D = [0] * N",
      "  n = 1",
      "  V = []",
      "  while D[x] == 0:",
      "    D[x] = n",
      "    V.append(x)",
      "    x = L[x]",
      "    n += 1",
      "  v = D[x] - 1",
      "  head, loop = V[:v], V[v:]",
      "",
      "  D = [0] * N",
      "  for i in range(len(head)):",
      "    D[head[i]] = 1",
      "    K -= 1",
      "    if K == 0: break",
      "  d, m = divmod(K, len(loop))",
      "  for i in range(len(loop)):",
      "    if i < m:",
      "      D[loop[i]] = d + 1",
      "    else:",
      "      D[loop[i]] = d",
      "  return D",
      ""
    ],
    "description": "周期",
    "scope": "python"
  },
  "prime": {
    "prefix": "prime",
    "body": [
      "import math",
      "def prime(x):",
      "  p = {}",
      "  last = math.floor(x ** 0.5)",
      "  if x % 2 == 0:",
      "    cnt = 1",
      "    x //= 2",
      "    while x & 1 == 0:",
      "      x //= 2",
      "      cnt += 1",
      "    p[2] = cnt",
      "  for i in range(3, last + 1, 2):",
      "    if x % i == 0:",
      "      x //= i",
      "      cnt = 1",
      "      while x % i == 0:",
      "        cnt += 1",
      "        x //= i",
      "      p[i] = cnt",
      "  if x != 1:",
      "    p[x] = 1",
      "  return p",
      ""
    ],
    "description": "素因数分解",
    "scope": "python"
  },
  "queue": {
    "prefix": "queue",
    "body": [
      "import queue",
      "q = queue.Queue()",
      "put = q.put",
      "get = q.get",
      ""
    ],
    "description": "キュー",
    "scope": "python"
  },
  "unionFind": {
    "prefix": "union",
    "body": [
      "class Union:",
      "  def __init__(s, num):",
      "    s.T = [-1] * num",
      "",
      "  def root(s, x):",
      "    if s.T[x] < 0: return x",
      "    t = s.root(s.T[x])",
      "    s.T[x] = t",
      "    return t",
      "",
      "  def merge(s, x, y):",
      "    an, bn = s.root(x), s.root(y)",
      "    if an == bn: return False",
      "    am, bm = -s.T[an], -s.T[bn]",
      "    if am < bm: an, bn = bn, an",
      "    s.T[an] += s.T[bn]",
      "    s.T[bn] = an",
      "    return True",
      "",
      "  def size(s, x):",
      "    n = s.root(x)",
      "    return -s.T[n]",
      "",
      "  def same(s, x, y):",
      "    return s.root(x) == s.root(y)",
      "",
      "  def print(s): #デバッグ用",
      "    print(*s.T)",
      "    ans = []",
      "    for i in range(len(s.T)):",
      "      ans.append(s.root(i))",
      "    print(*ans)",
      ""
    ],
    "description": "UnionFind",
    "scope": "python"
  },
  "rori": {
    "prefix": "rori",
    "body": [
      "class Rori:",
      "  B1 = 1009",
      "  B2 = 1007",
      "  MOD1 = 10 ** 9 + 7",
      "  MOD2 = 10 ** 9 + 9",
      "  H1, H2 = None, None",
      "  P1, P2 = None, None",
      "  def __init__(s, L):",
      "    n = len(L) + 1",
      "    s.H1 = [0] * n",
      "    s.H2 = [0] * n",
      "    s.P1 = [1] * n",
      "    s.P2 = [1] * n",
      "    for i in range(n - 1):",
      "      S = ord(L[i]) - ord('a') + 1",
      "      s.H1[i + 1] = (s.H1[i] * s.B1 + S) % s.MOD1",
      "      s.H2[i + 1] = (s.H2[i] * s.B2 + S) % s.MOD2",
      "      s.P1[i + 1] = s.P1[i] * s.B1 % s.MOD1",
      "      s.P2[i + 1] = s.P2[i] * s.B2 % s.MOD2",
      "  def hashLR(s, l, r):",
      "    t = ((s.H1[r] - s.H1[l] * s.P1[r - l]) % s.MOD1 + s.MOD1) % s.MOD1",
      "    k = ((s.H2[r] - s.H2[l] * s.P2[r - l]) % s.MOD2 + s.MOD2) % s.MOD2",
      "    return (t, k)",
      ""
    ],
    "description": "ローリングハッシュ",
    "scope": "python"
  },
  "scc": {
    "prefix": "scc",
    "body": [
      "import sys",
      "sys.setrecursionlimit(1000000)",
      "",
      "class scc_graph:",
      "  # n 頂点数",
      "  def __init__(s, n): ",
      "    s._n = n",
      "    s.g = {}",
      "  def num_vertices(s): return s._n",
      "  # 辺を追加 frm 矢元 to 矢先",
      "  # O(1)",
      "  def add_edge(s, frm, to): ",
      "    if frm in s.g: s.g[frm].append(to)",
      "    else: s.g[frm] = [to]",
      "",
      "  # グループの個数と各頂点のグループidを返す",
      "  def scc_ids(s):",
      "    now_ord = group_num = 0",
      "    visited = []",
      "    low = [0] * s._n",
      "    ord = [-1] * s._n",
      "    ids = [0] * s._n",
      "    # 再帰関数 ",
      "    def dfs(self, v, now_ord, group_num):",
      "      low[v] = ord[v] = now_ord",
      "      now_ord += 1",
      "      visited.append(v)",
      "      if v in s.g:",
      "        for to in s.g[v]:",
      "          if ord[to] == -1:",
      "            now_ord, group_num = self(self, to, now_ord, group_num)",
      "            low[v] = min(low[v], low[to])",
      "          else:",
      "            low[v] = min(low[v], ord[to])",
      "      if low[v] == ord[v]:",
      "        while True:",
      "          u = visited.pop()",
      "          ord[u] = s._n",
      "          ids[u] = group_num",
      "          if u == v: break",
      "        group_num += 1",
      "      return now_ord, group_num",
      "",
      "    for i in range(s._n):",
      "      if ord[i] == -1: now_ord, group_num = dfs(dfs, i, now_ord, group_num)",
      "    for i in range(s._n):",
      "      ids[i] = group_num - 1 - ids[i]",
      "    return group_num, ids",
      "",
      "  # 強連結成分となっている頂点のリストのリスト トポロジカルソート済み",
      "  # O(n + m)",
      "  def scc(s):",
      "    group_num, ids = s.scc_ids()",
      "    counts = [0] * group_num",
      "    for x in ids: counts[x] += 1",
      "    groups = [[] for _ in range(group_num)]",
      "    for i in range(s._n):",
      "      groups[ids[i]].append(i)",
      "    return groups",
      "",
      "  class edge:",
      "    def __init__(s, frm, to):",
      "      s.frm = frm",
      "      s.to = to",
      ""
    ],
    "description": "経連結成分分解",
    "scope": "python"
  },
  "segment_tree": {
    "prefix": "seg",
    "body": [
      "class segtree:",
      "  #セグメント木",
      "  def __init__(s, v, op, e):",
      "    s._n = len(v)",
      "    s.log = s.ceil_pow2(s._n)",
      "    s.size = 1 << s.log",
      "    s.d = [e()] * (2 * s.size)",
      "    s.e = e",
      "    s.op = op",
      "    for i in range(s._n): s.d[s.size + i] = v[i]",
      "    for i in range(s.size - 1, 0, -1): s.update(i)",
      "  ",
      "  # 1点更新",
      "  def set(s, p, x):",
      "    p += s.size",
      "    s.d[p] = x",
      "    for i in range(1, s.log + 1): s.update(p >> i)",
      " ",
      "  # 1点取得",
      "  def get(s, p):",
      "    return s.d[p + s.size]",
      " ",
      "  # 区間演算",
      "  def prod(s, l, r):",
      "    sml, smr = s.e(), s.e()",
      "    l += s.size",
      "    r += s.size",
      "    while (l < r):",
      "      if l & 1: ",
      "        sml = s.op(sml, s.d[l])",
      "        l += 1",
      "      if r & 1:",
      "        r -= 1",
      "        smr = s.op(s.d[r], smr)",
      "      l >>= 1",
      "      r >>= 1",
      "    return s.op(sml, smr)",
      " ",
      "  # 全体演算",
      "  def all_prod(s): return s.d[1]",
      " ",
      "  # L固定時の最長区間のR",
      "  def max_right(s, l, g):",
      "    if l == s._n: return s._n",
      "    l += s.size",
      "    sm = s.e()",
      "    while True:",
      "      while (l % 2 == 0): l >>= 1",
      "      if not g(s.op(sm, s.d[l])):",
      "        while l < s.size:",
      "          l = 2 * l",
      "          if g(s.op(sm, s.d[l])):",
      "            sm = s.op(sm, s.d[l])",
      "            l += 1",
      "        return l - s.size",
      "      sm = s.op(sm, s.d[l])",
      "      l += 1",
      "      if (l & -l) == l: break",
      "    return s._n",
      " ",
      "  # R固定時の最長区間のL",
      "  def min_left(s, r, g):",
      "    if r == 0: return 0",
      "    r += s.size",
      "    sm = s.e()",
      "    while True:",
      "      r -= 1",
      "      while r > 1 and (r % 2): r >>= 1",
      "      if not g(s.op(s.d[r], sm)):",
      "        while r < s.size:",
      "          r = 2 * r + 1",
      "          if g(s.op(s.d[r], sm)):",
      "            sm = s.op(s.d[r], sm)",
      "            r -= 1",
      "        return r + 1 - s.size",
      "      sm = s.op(s.d[r], sm)",
      "      if (r & - r) == r: break",
      "    return 0",
      " ",
      "  def update(s, k): s.d[k] = s.op(s.d[2 * k], s.d[2 * k + 1])",
      "  def ceil_pow2(s, n):",
      "    x = 0",
      "    while (1 << x) < n: x += 1",
      "    return x",
      "  def print(s): #デバッグ用",
      "    ans = []",
      "    for i in range(s._n):",
      "      ans.append(s.get(i))",
      "    print(*ans)",
      "  ",
      "class segtreeFactory:",
      "  MAX_INT = 10 ** 18",
      "  # サイズNのmaxSegTree",
      "  @staticmethod",
      "  def makeMaxSegTree(N,  v = None):",
      "    if v == None: v = [0] * N",
      "    return segtree(v, segtreeFactory.opmax, segtreeFactory.emax)",
      "  # サイズNのminSegTree",
      "  @staticmethod",
      "  def makeMinSegTree(N, v = None):",
      "    if v == None: v = [segtreeFactory.MAX_INT] * N",
      "    return segtree(v, segtreeFactory.opmin, segtreeFactory.emin)",
      "  # サイズNのsumSegTree",
      "  @staticmethod",
      "  def makeSumSegTree(N, v = None):",
      "    if v == None: v = [0] * N",
      "    return segtree(v, segtreeFactory.opsum, segtreeFactory.emax)",
      "  @staticmethod",
      "  def emax():",
      "    return 0",
      "  @staticmethod",
      "  def opmax(s, t):",
      "    return max(s, t)",
      "  @staticmethod",
      "  def emin():",
      "    return segtreeFactory.MAX_INT",
      "  @staticmethod",
      "  def opmin(s, t):",
      "    return min(s, t)",
      "  @staticmethod",
      "  def opsum(s, t):",
      "    return s + t",
      "  ",
      "seg = segtreeFactory.makeMaxSegTree(N)",
      ""
    ],
    "description": "セグメント木",
    "scope": "python"
  },
  "string": {
    "prefix": "string",
    "body": [
      "from functools import cmp_to_key",
      "THRESHOLD_NAIVE = 10",
      "THRESHOLD_DOUBLING = 40",
      "",
      "# ull以下の配列の接尾辞配列",
      "# O(n log n）",
      "# O(n + upper) upper指定時(upper <= 10^8)",
      "# O(n) sが文字列の時",
      "def suffix_array(s, upper = -1):",
      "  if type(s) == str: return suffix_array_str(s)",
      "  if upper == -1: return sa_is(s, upper)",
      "  def cmp(r, l):",
      "    return 1 if s[l] < s[r] else -1",
      "  n = len(s)",
      "  idx = [i for i in range(n)]",
      "  idx.sort(key=cmp_to_key(cmp))",
      "  s2 = [0] * n",
      "  now = 0",
      "  for i in range(n):",
      "    if i and s[idx[i - 1]] != s[idx[i]]: now += 1",
      "    s2[idx[i]] = now",
      "  return sa_is(s2, now)",
      "",
      "# 最長共通接頭辞配列",
      "# saはsのsuffix_array",
      "# O(n)",
      "def lcp_array(s, sa):",
      "  if type(s) == str: s = list(map(ord, s))",
      "  n = len(s)",
      "  rnk = [0] * n",
      "  for i in range(n):",
      "    rnk[sa[i]] = i",
      "  lcp = [0] * (n - 1)",
      "  h = 0",
      "  for i in range(n):",
      "    if h > 0: h -= 1",
      "    if rnk[i] == 0: continue",
      "    j = sa[rnk[i] - 1]",
      "    while j + h < n and i + h < n:",
      "      if s[j + h] != s[i + h]: break",
      "      h += 1",
      "    lcp[rnk[i] - 1] = h",
      "  return lcp",
      "",
      "# zアルゴリズム",
      "# Longest Common Prefix",
      "def z_algorithm(s):",
      "  if type(s) == str: s = list(map(ord, s))",
      "  n = len(s)",
      "  if n == 0: return []",
      "  z = [0] * n",
      "  j = 0",
      "  for i in range(1, n):",
      "    z[i] = 0 if j + z[j] <= i else min(j + z[j] - i, z[i - j])",
      "    while i + z[i] < n and s[z[i]] == s[i + z[i]]: z[i] += 1",
      "    if j + z[j] < i + z[i]: j = i",
      "  z[0] = n",
      "  return z",
      "",
      "# O(n + upper)",
      "def sa_is(s, upper):",
      "  n = len(s)",
      "  if n == 0: return []",
      "  if n == 1: return [0]",
      "  if n == 2:",
      "    if s[0] < s[1]: return [0, 1]",
      "    else: return [1, 0]",
      "  if n < THRESHOLD_NAIVE:",
      "    return sa_naive(s)",
      "  if n < THRESHOLD_DOUBLING:",
      "    return sa_doubling(s)",
      "",
      "  sa = [0] * n",
      "  ls = [False] * n",
      "  for i in range(n - 2, -1, -1):",
      "    ls[i] = ls[i + 1] if s[i] == s[i + 1] else s[i] < s[i + 1]",
      "  sum_l = [0] * (upper + 1)",
      "  sum_s = [0] * (upper + 1)",
      "  for i in range(n):",
      "    if not ls[i]: sum_s[s[i]] += 1",
      "    else: sum_l[s[i] + 1] += 1",
      "  for i in range(upper + 1):",
      "    sum_s[i] += sum_l[i]",
      "    if i < upper: sum_l[i + 1] += sum_s[i]",
      "",
      "  def induce(lms):",
      "    for i in range(n): sa[i] = -1",
      "    buf = [0] * (upper + 1)",
      "    for i in range(len(sum_s)): buf[i] = sum_s[i]",
      "    for d in lms:",
      "      if d == n: continue",
      "      sa[buf[s[d]]] = d",
      "      buf[s[d]] += 1",
      "    for i in range(len(sum_l)): buf[i] = sum_l[i]",
      "    sa[buf[s[n - 1]]] = n - 1",
      "    buf[s[n - 1]] += 1",
      "    for i in range(n):",
      "      v = sa[i]",
      "      if v >= 1 and not ls[v - 1]:",
      "        sa[buf[s[v - 1]]] = v - 1",
      "        buf[s[v - 1]] += 1",
      "    for i in range(len(sum_l)): buf[i] = sum_l[i]",
      "    for i in range(n - 1, -1, -1):",
      "      v = sa[i]",
      "      if v >= 1 and ls[v - 1]:",
      "       buf[s[v - 1] + 1] -= 1",
      "       sa[buf[s[v - 1] + 1]] = v - 1",
      "",
      "  lms_map = [-1] * (n + 1)",
      "  m = 0",
      "  for i in range(1, n):",
      "    if not ls[i - 1] and ls[i]:",
      "      lms_map[i] = m",
      "      m += 1",
      "  lms = []",
      "  for i in range(1, n):",
      "    if not ls[i - 1] and ls[i]:",
      "      lms.append(i)",
      "",
      "  induce(lms)",
      "",
      "  if m:",
      "    sorted_lms = []",
      "    for v in sa:",
      "      if lms_map[v] != -1: sorted_lms.append(v)",
      "    rec_s = [0] * m",
      "    rec_upper = 0",
      "    rec_s[lms_map[sorted_lms[0]]] = 0",
      "    for i in range(1, m):",
      "      l, r = sorted_lms[i - 1], sorted_lms[i]",
      "      end_l = lms[lms_map[l] + 1] if lms_map[l] + 1 < m else n",
      "      end_r = lms[lms_map[r] + 1] if lms_map[r] + 1 < m else n",
      "      same = True",
      "      if end_l - l != end_r - r:",
      "        same = False",
      "      else:",
      "        while l < end_l:",
      "          if s[l] != s[r]: break",
      "          l += 1",
      "          r += 1",
      "        if l == n or s[l] != s[r]: same = False",
      "      if not same: rec_upper += 1",
      "      rec_s[lms_map[sorted_lms[i]]] = rec_upper",
      "",
      "    rec_sa = sa_is(rec_s, rec_upper)",
      "",
      "    for i in range(m):",
      "      sorted_lms[i] = lms[rec_sa[i]]",
      "    induce(sorted_lms)",
      "",
      "  return sa",
      "",
      "# ナイーブ実装",
      "# O(n^2 log n)",
      "def sa_naive(s):",
      "  def cmp(r, l):",
      "    if l == r: return -1",
      "    while (l < n and r < n):",
      "      if s[l] != s[r]: return 1 if s[l] < s[r] else -1",
      "      l += 1",
      "      r += 1",
      "    return 1 if l == n else -1",
      "  n = len(s)",
      "  sa = [i for i in range(n)]",
      "  sa.sort(key=cmp_to_key(cmp))",
      "  return sa",
      "#doubling",
      "def sa_doubling(s):",
      "  n = len(s)",
      "  sa = [i for i in range(n)]",
      "  rnk = s",
      "  tmp = [0] * n",
      "  k = 1",
      "  while k < n:",
      "    def cmp(y, x):",
      "      if rnk[x] != rnk[y]: return 1 if rnk[x] < rnk[y] else -1",
      "      rx = rnk[x + k] if x + k < n else -1",
      "      ry = rnk[y + k] if y + k < n else -1",
      "      return 1 if rx < ry else -1",
      "    sa.sort(key=cmp_to_key(cmp))",
      "    tmp[sa[0]] = 0",
      "    for i in range(1, n):",
      "      tmp[sa[i]] = tmp[sa[i - 1]] + (1 if cmp(sa[i], sa[i - 1]) == 1 else 0)",
      "    tmp, rnk = rnk, tmp",
      "    k *= 2",
      "  return sa",
      "",
      "# 文字列の接尾辞配列",
      "# O(n)",
      "def suffix_array_str(s):",
      "  n = len(s)",
      "  s2 = list(map(ord, s))",
      "  return sa_is(s2, 255)",
      ""
    ],
    "description": "文字列操作アルゴリズム",
    "scope": "python"
  },
  "tentou": {
    "prefix": "tentou",
    "body": [
      "class BIT:",
      "  ini = 0",
      "  def __init__(s, num):",
      "    s.N = 1",
      "    while s.N <= num:",
      "      s.N *= 2",
      "    s.T = [s.ini] * s.N",
      "  def set(s, L):",
      "    for i in range(len(L)):",
      "      s.update(i, L[i])",
      "  def update(s, x, n): # xにnを加える",
      "    k = x + 1",
      "    s.T[k - 1] += n",
      "    k += k & -k",
      "    while k <= s.N:",
      "      s.T[k - 1] += n",
      "      k += k & -k",
      "  def getV(s, x): # xまでの和(x含む)",
      "    if x < 0: return 0",
      "    x += 1",
      "    ans = s.T[x - 1]",
      "    x -= x & -x",
      "    while x != 0:",
      "      ans += s.T[x - 1]",
      "      x -= x & -x",
      "    return ans",
      " ",
      "import copy",
      "def tentou(L):",
      "  if len(L) <= 1:",
      "    return 0",
      "  D = copy.deepcopy(L)",
      "  D.sort()",
      "  R = {}",
      "  cnt = 0",
      "  for d in D:",
      "    if d not in R:",
      "      R[d] = cnt",
      "      cnt += 1",
      "  b = BIT(cnt + 1)",
      "  ans = (len(L) * (len(L) - 1)) // 2",
      "  for d in L:",
      "    d = R[d]",
      "    ans -= b.getV(d)",
      "    b.update(d, 1)",
      "  return ans",
      ""
    ],
    "description": "転倒数",
    "scope": "python"
  },
  "totu": {
    "prefix": "totu",
    "body": [
      "import math",
      "def det(p, q):",
      "    return p[0]*q[1] - p[1]*q[0]",
      "def sub(p, q):",
      "    return (p[0]-q[0], p[1]-q[1])",
      "def get_convex_hull(points):",
      "    # どの3点も直線上に並んでいないと仮定する。",
      "    n = len(points)",
      "    points.sort()",
      "    size_convex_hull = 0",
      "    ch = []",
      "    for i in range(n):",
      "        while size_convex_hull > 1:",
      "            v_cur = sub(ch[-1], ch[-2])",
      "            v_new = sub(points[i], ch[-2])",
      "            if det(v_cur, v_new) > 0:",
      "                break",
      "            size_convex_hull -= 1",
      "            ch.pop()",
      "        ch.append(points[i])",
      "        size_convex_hull += 1",
      "    t = size_convex_hull",
      "    for i in range(n-2, -1, -1):",
      "        while size_convex_hull > t:",
      "            v_cur = sub(ch[-1], ch[-2])",
      "            v_new = sub(points[i], ch[-2])",
      "            if det(v_cur, v_new) > 0:",
      "                break",
      "            size_convex_hull -= 1",
      "            ch.pop()",
      "        ch.append(points[i])",
      "        size_convex_hull += 1",
      "    return ch[:-1]",
      "",
      "# 多角形の面積 * 2 (2をかけると必ず整数になる)",
      "def area(points):",
      "  ans = 0",
      "  N = len(points)",
      "  x0, y0 = points[N - 1]",
      "  for i in range(N):",
      "    x1, y1 = points[i]",
      "    ans += (x0 - x1) * (y0 + y1)",
      "    x0, y0 = x1, y1",
      "  return abs(ans)",
      "",
      "# 多角形の線分上の格子点の数の和",
      "def all_points_ontotu(points):",
      "  ans = 0",
      "  N = len(points)",
      "  x0, y0 = points[N - 1]",
      "  for i in range(N):",
      "    x1, y1 = points[i]",
      "    ans += points_online(x0, y0, x1, y1) - 1",
      "    x0, y0 = x1, y1",
      "  return ans",
      "",
      "# 線分上の格子点の数",
      "def points_online(x0, y0, x1, y1):",
      "  return math.gcd(abs(x0 - x1), abs(y0 - y1)) + 1",
      "",
      "# 凸包に含まれる格子点の数",
      "def inner_points(points):",
      "  D = get_convex_hull(points)",
      "  S2 = area(D)",
      "  b = all_points_ontotu(D)",
      "  # ピックの定理で凸包に含まれる格子点の数を求める",
      "  ans = (S2 - b) // 2 + 1",
      "  ans += b # (辺上の格子点を含める)",
      "  return ans",
      ""
    ],
    "description": "凸法",
    "scope": "python"
  },
  "touhi": {
    "prefix": "touhi",
    "body": [
      "# 初項x 公比x 項数t の等比数列の和",
      "def nib(x, t, MOD):",
      "  # [和, その項の値]",
      "  if t == 0: return [0, 1]",
      "  p = nib(x, t >> 1)",
      "  p[0] += p[0] * p[1]",
      "  p[0] %= MOD",
      "  p[1] *= p[1]",
      "  p[1] %= MOD",
      "  if t & 1:",
      "    p[1] *= x",
      "    p[1] % MOD",
      "    p[0] += p[1]",
      "    p[0] %= MOD",
      "  return p",
      ""
    ],
    "description": "等比数列の和",
    "scope": "python"
  },
  "tousa": {
    "prefix": "tousa",
    "body": [
      "class Imos:",
      "  def __init__(self, N) -> None:",
      "    self.N = N",
      "    self.A = [0]*(N+2)",
      "  def add_line(self, l, r, a, d) -> None:",
      "    # [l, r) に初項a, 公差d の等差数列を加算",
      "    self.A[l] += a",
      "    self.A[l+1] += d-a",
      "    self.A[r] -= d*(r-l)+a",
      "    self.A[r+1] += d*(r-l-1)+a",
      "  def get_array(self) -> None:",
      "    # 現在の数列を取得",
      "    ret = [0]*self.N",
      "    ret[0] = self.A[0]",
      "    for i in range(self.N-1):",
      "        ret[i+1] = ret[i]+self.A[i+1]",
      "    for i in range(self.N-1):",
      "        ret[i+1] += ret[i]",
      "    return ret"
    ],
    "description": "区間に等差数列を足す",
    "scope": "python"
  },
  "tree": {
    "prefix": "tree",
    "body": [
      "class Tree:",
      "  def __init__(s, num):",
      "    s.N = num",
      "    s.C = {}",
      "    s.RL = {}",
      "  # 隣接リストから木作成 1-indexedならindex = 1にする",
      "  def setByAdjacencyList(s, list, index = 0):",
      "    for u, v in list:",
      "      u -= index",
      "      v -= index",
      "      s.set(u, v)",
      "  # 親リストから木作成 1-indexedならindex = 1にする",
      "  def setByParentList(s, list, index = 0):",
      "    for i in range(s.N - 1):",
      "      s.set(i + 1, list[i] - index)",
      "  def set(s, a, b):",
      "    if a in s.C: s.C[a].append(b)",
      "    else: s.C[a] = [b]",
      "    if b in s.C: s.C[b].append(a)",
      "    else: s.C[b] = [a]",
      "  def makeRank(s, root):",
      "    s.R = [-1] * s.N #各ノードのランク",
      "    s.R[root] = 0",
      "    s.RL[0] = [root] #各ランクのノード",
      "    s.S = {} #各ノードの子ノード",
      "    s.P = [-1] * s.N #各ノードの親ノード",
      "    s.D = 0",
      "    while s.RL[s.D] != []:",
      "      s.D += 1",
      "      s.RL[s.D] = []",
      "      for i in s.RL[s.D - 1]:",
      "        for j in s.C[i]:",
      "          if s.R[j] == -1:",
      "            s.R[j] = s.D",
      "            s.RL[s.D].append(j)",
      "            if i not in s.S: s.S[i] = [j]",
      "            else: s.S[i].append(j)",
      "            s.P[j] = i    ",
      "  def dfs(s, x, y, r): #xからyまでの道O(M)",
      "    if x == y:",
      "      return [x]",
      "    for i in s.C[x]:",
      "      if i != r:",
      "        t = s.dfs(i, y, x)",
      "        if t != False:",
      "          return [x] + t",
      "    return False",
      "  def dist(s, x): #最遠のノード,距離",
      "    t = [-1] * s.N",
      "    S = [x]",
      "    ans = x",
      "    ansn = 0",
      "    t[x] = 0",
      "    while S != []:",
      "      k = S.pop()",
      "      for i in s.C[k]:",
      "        if t[i] == -1:",
      "          t[i] = t[k] + 1",
      "          S.append(i)",
      "          if t[i] > ansn:",
      "            ansn = t[i]",
      "            ans = i",
      "    return ans, ansn",
      "  def getDi(s, x = 0): #直径",
      "    a, _ = s.dist(x)",
      "    b, ans = s.dist(a)",
      "    return ans, a, b",
      "  def getDeep(s, x): #xの子孫のうち一番深い深さ",
      "    ans = 0",
      "    if x in s.S:",
      "      for i in s.S[x]:",
      "        ans = max(ans, s.getDeep(i))",
      "      return ans + 1",
      "    else:",
      "      return 0",
      "  def tour(s): #オイラーツアー",
      "    x = s.RL[0][0]",
      "    s.T = [] #ツアー",
      "    L = [x]",
      "    while L:",
      "      n = L.pop()",
      "      if n < 0:",
      "        x = n * -1 - 1",
      "        s.T.append(x)",
      "        continue",
      "      s.T.append(n)",
      "      if n in s.S:",
      "        for x in (s.S[n]):",
      "          L.append(-(n + 1))",
      "          L.append(x)",
      "    return s.T",
      "  def tourFL(s): # オイラーツアー後に実施",
      "    s.First = [-1] * s.N # 各頂点の最初の出現位置",
      "    s.Last = [-1] * s.N # 各頂点の最後の出現位置",
      "    M = len(s.T)",
      "    for i in range(M):",
      "      if s.First[s.T[i]] == -1:",
      "        s.First[s.T[i]] = i",
      "      s.Last[s.T[i]] = i",
      "  # 頂点集合から、頂点同士の関係を失わないように木を圧縮したもののリストを返す",
      "  # v = [[頂点集合1], [頂点集合2], ...]",
      "  # 先にmakeRankしておくこと",
      "  # return [[親Noリスト], [頂点Noリスト], [頂点No→連番への写像map]] のリスト",
      "  def makeAuxiliaryTree(s, V):",
      "    s.tour()",
      "    s.tourFL()",
      "    s.makeDub()",
      "    return s.makeAuxiliaryTree_sub(V)",
      "  ",
      "  def makeAuxiliaryTree_sub(s, V):",
      "    ans = []",
      "    for D in V:",
      "      T = []",
      "      for d in D:",
      "        T.append([s.First[d], d])",
      "      T.sort()",
      "      T = [d[1] for d in T]",
      "      T2 = [T[0]]",
      "      for i in range(1, len(T)):",
      "        l = T[i - 1]",
      "        n = T[i]",
      "        m = s.getLCA(l, n)",
      "        T2.append(m)",
      "        T2.append(n)",
      "      T2 = list(set(T2))",
      "      T2 = [[s.First[d], d] for d in T2]",
      "      T2.sort()",
      "      T2 = [d[1] for d in T2]",
      "      st = [T2[0]]",
      "      data = [[] for _ in range(2)]",
      "      data.append({})",
      "      data[1] = [T2[0]]",
      "      data[2][T2[0]] = 0",
      "      for y in T2[1:]:",
      "        while st:",
      "          x = st.pop()",
      "          if s.Last[x] >= s.First[y]:",
      "            st.append(x)",
      "            st.append(y)",
      "            data[2][y] = len(data[1])",
      "            data[1].append(y)",
      "            data[0].append(data[2][x])",
      "            break",
      "      ans.append(data)",
      "    return ans",
      "  def makeDub(s):",
      "    s.dub = [[] for _ in range(s.N)]",
      "    for i in range(1, s.D):",
      "      for d in s.RL[i]:",
      "        n = s.P[d]",
      "        s.dub[d].append(n)",
      "        t = 0",
      "        while len(s.dub[n]) > t:",
      "          s.dub[d].append(s.dub[n][t])",
      "          n = s.dub[n][t]",
      "          t += 1",
      "  def getParent(s, x, n): #xのn世代前の親",
      "    #先にmakeDubしておくこと",
      "    if n == 0: return x",
      "    t = s.R[x]",
      "    if t >= n:",
      "      ans = x",
      "      v = 0",
      "      while n != 0:",
      "        if n & 1:",
      "          ans = s.dub[ans][v]",
      "        n >>= 1",
      "        v += 1",
      "      return ans",
      "    else:",
      "      return -1",
      "  def getLCA(s, u, v):",
      "    #先にmakeDubしておくこと",
      "    if s.R[u] < s.R[v]: ",
      "      u, v = v, u",
      "    u = s.getParent(u, s.R[u] - s.R[v])",
      "    if u == v: return u",
      "    K = len(s.dub[u])",
      "    for k in range(K - 1, -1, -1):",
      "      if len(s.dub[u]) <= k: continue",
      "      if s.dub[u][k] != s.dub[v][k]:",
      "        u = s.dub[u][k]",
      "        v = s.dub[v][k]",
      "    return s.dub[u][0]",
      ""
    ],
    "description": "木構造",
    "scope": "python"
  },
  "treedp": {
    "prefix": "treedp",
    "body": [
      "class Tree:",
      "  def __init__(s, num):",
      "    s.N = num",
      "    s.C = {}",
      "    s.RL = {}",
      "  # 隣接リストから木作成 1-indexedならindex = 1にする",
      "  def setByAdjacencyList(s, list, index = 0):",
      "    for u, v in list:",
      "      u -= index",
      "      v -= index",
      "      s.set(u, v)",
      "  # 親リストから木作成 1-indexedならindex = 1にする",
      "  def setByParentList(s, list, index = 0):",
      "    for i in range(s.N - 1):",
      "      s.set(i + 1, list[i] - index)",
      "  def set(s, a, b):",
      "    if a in s.C: s.C[a].append(b)",
      "    else: s.C[a] = [b]",
      "    if b in s.C: s.C[b].append(a)",
      "    else: s.C[b] = [a]",
      "  def makeRank(s, root):",
      "    s.R = [-1] * s.N #各ノードのランク",
      "    s.R[root] = 0",
      "    s.RL[0] = [root] #各ランクのノード",
      "    s.S = {} #各ノードの子ノード",
      "    s.P = [-1] * s.N #各ノードの親ノード",
      "    s.D = 0",
      "    while s.RL[s.D] != []:",
      "      s.D += 1",
      "      s.RL[s.D] = []",
      "      for i in s.RL[s.D - 1]:",
      "        for j in s.C[i]:",
      "          if s.R[j] == -1:",
      "            s.R[j] = s.D",
      "            s.RL[s.D].append(j)",
      "            if i not in s.S: s.S[i] = [j]",
      "            else: s.S[i].append(j)",
      "            s.P[j] = i     ",
      "  def bottomUpDP(s):",
      "    for i in range(s.D - 1, -1, -1):",
      "      T = s.RL[i]",
      "      for j in T:",
      "        if j not in s.S: continue",
      "        for k in s.S[j]:",
      "          s.dp_sub_exe(j, k)",
      "  def topDownDP(s):",
      "    for i in range(1, s.D):",
      "      T = s.RL[i]",
      "      for j in T:",
      "        s.dp_sub_exe_inv(j, s.P[j])",
      "  def allDP(s):",
      "    s.dp_init()",
      "    s.bottomUpDP()",
      "    s.topDownDP()",
      "    return s.DP",
      "  def dp_init(s): #単位元で初期化",
      "    s.DP = [1] * s.N",
      "  def dp_sub_exe(s, x, y): #ボトムアップの処理",
      "    s.DP[x] += s.DP[y]",
      "  def dp_sub_exe_inv(s, x, y): #トップダウンの処理",
      "    s.DP[x] += s.DP[y]",
      "  def inv(s, a, mod): #逆元",
      "    return pow(a, mod - 2, mod)",
      ""
    ],
    "description": "木DP",
    "scope": "python"
  },
  "twosat": {
    "prefix": "twosat",
    "body": [
      "import sys",
      "sys.setrecursionlimit(1000000)",
      "",
      "# 2-SAT",
      "class two_sat:",
      "  def __init__(s):",
      "    s._n = 0",
      "    s.scc = scc_graph(0)",
      "  def __init__(s, n):",
      "    s._n = n",
      "    s._answer = [False] * n",
      "    s.scc = scc_graph(2 * n)",
      "",
      "  # クローズを足す",
      "  def add_clause(s, i, f, j, g):",
      "    s.scc.add_edge(2 * i + (not f), 2 * j + (g))",
      "    s.scc.add_edge(2 * j + (not g), 2 * i + (f))",
      "  ",
      "  # 判定",
      "  # O(n + m)",
      "  def satisfiable(s):",
      "    id = s.scc.scc_ids()[1]",
      "    for i in range(s._n):",
      "      if id[2 * i] == id[2 * i + 1]: return False",
      "      s._answer[i] = id[2 * i] < id[2 * i + 1]",
      "    return True",
      "",
      "  # クローズを満たす割当を返す",
      "  # satisfiableがTrueとなった後に呼ばないと意味ない",
      "  # O(1）",
      "  def answer(s): return s._answer",
      "",
      "class scc_graph:",
      "  # n 頂点数",
      "  def __init__(s, n): ",
      "    s._n = n",
      "    s.g = {}",
      "  def num_vertices(s): return s._n",
      "  # 辺を追加 frm 矢元 to 矢先",
      "  # O(1)",
      "  def add_edge(s, frm, to): ",
      "    if frm in s.g: s.g[frm].append(to)",
      "    else: s.g[frm] = [to]",
      "",
      "  # グループの個数と各頂点のグループidを返す",
      "  def scc_ids(s):",
      "    now_ord = group_num = 0",
      "    visited = []",
      "    low = [0] * s._n",
      "    ord = [-1] * s._n",
      "    ids = [0] * s._n",
      "    # 再帰関数 ",
      "    def dfs(self, v, now_ord, group_num):",
      "      low[v] = ord[v] = now_ord",
      "      now_ord += 1",
      "      visited.append(v)",
      "      if v in s.g:",
      "        for to in s.g[v]:",
      "          if ord[to] == -1:",
      "            now_ord, group_num = self(self, to, now_ord, group_num)",
      "            low[v] = min(low[v], low[to])",
      "          else:",
      "            low[v] = min(low[v], ord[to])",
      "      if low[v] == ord[v]:",
      "        while True:",
      "          u = visited.pop()",
      "          ord[u] = s._n",
      "          ids[u] = group_num",
      "          if u == v: break",
      "        group_num += 1",
      "      return now_ord, group_num",
      "",
      "    for i in range(s._n):",
      "      if ord[i] == -1: now_ord, group_num = dfs(dfs, i, now_ord, group_num)",
      "    for i in range(s._n):",
      "      ids[i] = group_num - 1 - ids[i]",
      "    return group_num, ids",
      "",
      "  # 強連結成分となっている頂点のリストのリスト トポロジカルソート済み",
      "  # O(n + m)",
      "  def scc(s):",
      "    group_num, ids = s.scc_ids()",
      "    counts = [0] * group_num",
      "    for x in ids: counts[x] += 1",
      "    groups = [[] for _ in range(group_num)]",
      "    for i in range(s._n):",
      "      groups[ids[i]].append(i)",
      "    return groups",
      "",
      "  class edge:",
      "    def __init__(s, frm, to):",
      "      s.frm = frm",
      "      s.to = to",
      ""
    ],
    "description": "2-SAT",
    "scope": "python"
  },
  "warflo": {
    "prefix": "warflo",
    "body": [
      "class warflo:",
      "  def __init__(s, N, inf):",
      "    s.inf = inf",
      "    s.D = [[s.inf] * N for _ in range(N)]",
      "    s.V = [[0] * N for _ in range(N)]",
      "    s.N = N",
      "  # aからbへcの辺を張る（負の辺は不可）",
      "  def add (s, a, b, c):",
      "    s.D[a][b] = c",
      "  # O(N^3)で各点間の距離を求める",
      "  def exe(s):",
      "    for i in range(s.N):",
      "      for j in range(s.N):",
      "        s.V[i][j] = i",
      "      s.D[i][i] = 0",
      "    for k in range(s.N):",
      "      for i in range(s.N):",
      "        for j in range(s.N):",
      "          if s.D[i][k] + s.D[k][j] < s.D[i][j]:",
      "            s.D[i][j] = s.D[i][k] + s.D[k][j]",
      "            s.V[i][j] = s.V[k][j]",
      "    return s.D",
      "  # aからbの経路を求める(先にexeをすること）",
      "  def route(s, a, b):",
      "    if s.D[a][b] == s.inf:",
      "      return []",
      "    c = b",
      "    L = [b]",
      "    while c != a:",
      "      c = s.V[a][c]",
      "      L.append(c)",
      "    L.reverse()",
      "    return L",
      ""
    ],
    "description": "ワーシャルフロイド法",
    "scope": "python"
  },
  "wavelet": {
    "prefix": "wavelet",
    "body": [
      "import math",
      "import heapq",
      "from collections import deque",
      "pop = heapq.heappop",
      "push = heapq.heappush",
      "class wavelet:",
      "  class bitvec:",
      "    def __init__(s, B):",
      "      N = len(B)",
      "      s.bn = 32",
      "      s.B = [0] * -(-N // s.bn)",
      "      for i in range(-(-N // s.bn)):",
      "        for j in range(s.bn):",
      "          if i * s.bn + j == N:",
      "            s.B[i] <<= s.bn - j",
      "            break",
      "          s.B[i] <<= 1",
      "          s.B[i] += int(B[i * s.bn + j])",
      "      # N = 2 ^ 28 とすると",
      "      s.ln = 784 # 28 ** 2",
      "      s.sn = 14 # 28 / 2",
      "      ls = -(-N // s.ln)",
      "      ss = -(-N // s.sn) ",
      "      ps = pow(2, s.sn)",
      "      s.L = []",
      "      s.S = []",
      "      lcnt, scnt = 0, 0",
      "      for i in range(N):",
      "        if i % s.ln == 0:",
      "          s.L.append(lcnt)",
      "          s.S.append([])",
      "          scnt = 0",
      "        if i % s.sn == 0:",
      "          s.S[-1].append(scnt)",
      "        if B[i]:",
      "          lcnt += 1",
      "          scnt += 1",
      "      s.P = [0] * ps",
      "      for i in range(1, s.sn + 1):",
      "        n = (1 << i) - 1",
      "        while n < (1 << s.sn):",
      "          s.P[n] = i",
      "          x = n & -n",
      "          y = n + x",
      "          n = ((n & ~y) // x >> 1) | y",
      "    def access(s, n):",
      "      # 先頭からn番目の値(0-indexed)",
      "      i = n // s.bn",
      "      k = n % s.bn",
      "      return (s.B[i] >> (s.bn - 1 - k)) & 1",
      "    def rank(s, n):",
      "      # 先頭からn番目までの1の数(1-indexed)",
      "      if n <= 0: return 0",
      "      n -= 1",
      "      x = n // s.ln",
      "      y = (n - x * s.ln) // s.sn",
      "      l = s.sn * y",
      "      r = n",
      "      if l // s.bn != r // s.bn:",
      "        p = s.B[l // s.bn] & ((1 << (s.bn - (l % s.bn))) - 1)",
      "        p <<= (r % s.bn) + 1",
      "        p += s.B[r // s.bn] >> (s.bn - 1 - (r % s.bn))",
      "      else:",
      "        p = s.B[l // s.bn] & ((1 << (s.bn - (l % s.bn))) - 1)",
      "        p >>= (s.bn - 1 - (r % s.bn))",
      "      return  s.L[x] + s.S[x][y] + s.P[p]",
      "    def rankzero(s, n):",
      "      # 先頭からn番目までの0の数(1-indexed)",
      "      return n - s.rank(n)",
      "    def select(s, n, b):",
      "      # 先頭からn番目のb(0 or 1)の位置(0-indexed)",
      "      if n <= 0: return -1",
      "      p = s.nibutan(s.L, n, b, s.ln)",
      "      n -= s.L[p] if b else s.ln * p - s.L[p]",
      "      q = s.nibutan(s.S[p], n, b, s.sn)",
      "      n -= s.S[p][q] if b else s.sn * q - s.S[p][q]",
      "      t = s.ln * p + s.sn * q",
      "      try:",
      "        while True:",
      "          if s.access(t) == b:",
      "            n -= 1",
      "            if n == 0:",
      "              return t",
      "          t += 1",
      "      except:",
      "        return -1",
      "",
      "    def nibutan(s, L, n, b, num):",
      "      ok = 0",
      "      ng = len(L)",
      "      while abs(ok - ng) > 1:",
      "        mid = (ok + ng) // 2",
      "        x = L[mid] if b else num * mid - L[mid]",
      "        if x < n: ok = mid",
      "        else: ng = mid",
      "      return ok",
      "",
      "  def __init__(s, T):",
      "    # 索引作成 負の数は不可",
      "    N = len(T)",
      "    t = 0",
      "    for i in range(N): t = max(t, math.ceil(math.log2(T[i] + 1)) - 1)",
      "    s.digit = t # 桁数",
      "    s.B = [] # 索引",
      "    s.BN = [] # 0の個数",
      "    s.R = {} # 最終値の各数値の開始値",
      "    D = [[0, 0, T[i]] for i in range(N)]",
      "    for n in range(t, -1, -1):",
      "      ND = []",
      "      cnt = 0",
      "      for i in range(N):",
      "        ND.append([(D[i][2] >> n) & 1, i, D[i][2]])",
      "        cnt += 1 - ND[i][0]",
      "      s.B.append(s.bitvec([ND[i][0] for i in range(N)]))",
      "      s.BN.append(cnt)",
      "      ND.sort()",
      "      D = ND",
      "    for i in range(N):",
      "      if D[i][2] not in s.R:",
      "        s.R[D[i][2]] = [i, 1]",
      "      else:",
      "        s.R[D[i][2]][1] += 1",
      "  def access(s, n):",
      "    # n番目(0-indexed)の位置の値(logσ)",
      "    ans = 0",
      "    for i in range(s.digit + 1):",
      "      ans <<= 1",
      "      if s.B[i].access(n):",
      "        ans += 1",
      "        n = s.B[i].rank(n) + s.BN[i]",
      "      else:",
      "        n = s.B[i].rankzero(n)",
      "    return ans",
      "  def rank(s, n, c):",
      "    # n番目(0-indexed)までにcが現れた個数(logσ)",
      "    n += 1",
      "    for i in range(s.digit + 1):",
      "      if (c >> (s.digit - i)) & 1:",
      "        n = s.B[i].rank(n) + s.BN[i]",
      "      else:",
      "        n = s.B[i].rankzero(n)",
      "    return n - s.R[c]",
      "  def select(s, c, n):",
      "    # n個目のcの位置(0-indexed)(logσ)",
      "    if c not in s.R: return -1",
      "    d, m = s.R[c]",
      "    if not 1 <= n <= m : return -1",
      "    n = d + n",
      "    for i in range(s.digit, -1, -1):",
      "      if (c >> (s.digit - i)) & 1:",
      "        n = s.B[i].select(n - s.BN[i], 1) + 1",
      "      else:",
      "        n = s.B[i].select(n, 0) + 1",
      "    return n - 1",
      "  def quantile(s, st, en, r):",
      "    # st <= i <= en の間で r番目に小さい値(0-indexed)(logσ)",
      "    if en - st < r : return -1",
      "    en += 1",
      "    ans = 0",
      "    for i in range(s.digit + 1):",
      "      ans <<= 1",
      "      z = s.B[i].rankzero(en) - s.B[i].rankzero(st)",
      "      if r < z:",
      "        x = s.B[i].rankzero(st)",
      "        st = x",
      "        en = st + z - 1",
      "      else:",
      "        x = s.B[i].rank(st)",
      "        st = s.BN[i] + x",
      "        x = s.B[i].rank(en)",
      "        en = s.BN[i] + x",
      "        r -= z",
      "        ans += 1",
      "    return ans",
      "  def topk(s, st, en, k):",
      "    # st <= i <= en の間で出現回数が多い順にk個返す(0-indexed)(min(e - s, σ)logσ)",
      "    en += 1",
      "    q  = []",
      "    push(q, [-(en - st), st, 0, 0])",
      "    ans = []",
      "    while k > 0 and q:",
      "      n, st, x, i = pop(q)",
      "      if i == s.digit + 1:",
      "        ans.append([x, -n])",
      "        k -= 1",
      "        continue",
      "      en = st - n",
      "      z = s.B[i].rankzero(en) - s.B[i].rankzero(st)",
      "      if z != 0:",
      "        o = s.B[i].rankzero(st)",
      "        push(q, [-z, o, x << 1, i + 1])",
      "      if z != -n:",
      "        o = s.BN[i] + s.B[i].rank(st)",
      "        push(q, [z + n, o, (x << 1) + 1, i + 1])",
      "    return ans",
      "  def sum(s, st, en):",
      "    # st <= i <= en の和(0-indexed)(min(e - s, σ)logσ)",
      "    tk = topk(st, en, en - st + 1)",
      "    ans = 0",
      "    for a, b in tk:",
      "      ans += a * b",
      "    return ans",
      "  def intersect (s, s1, e1, s2, e2):",
      "    # st <= i <= en の和(0-indexed)(e1 - s1 + e2 - s1 + 1)",
      "    d = deque()",
      "    d.append(s1, e1, s2, e2)",
      "    while not d.empty():",
      "      pass",
      "    #途中",
      ""
    ],
    "description": "ウェーブレットマトリクス",
    "scope": "python"
  },
  "ragu": {
    "prefix": "ragu",
    "body": [
      "class Inv:",
      "  def __init__(s, mod):",
      "    s.MOD = mod",
      "  def modpow(s, a, n):",
      "    res = 1",
      "    while n > 0:",
      "      if n & 1:",
      "        res = res * a % s.MOD",
      "      a = a * a % s.MOD",
      "      n >>= 1",
      "    return res",
      "  def invx(s, a):",
      "    return s.modpow(a, s.MOD - 2)",
      "  def invpowL(s, a, n): # a^-x (0 <= x <= n)リスト",
      "    ia = s.invx(a)",
      "    L = [1] * (n + 1)",
      "    for i in range(1, n + 1):",
      "      L[i] = L[i - 1] * ia % s.MOD",
      "    return L",
      "  def invL(s, n): # 0 <= x <= n 逆元リスト",
      "    I = [0, 1]",
      "    for i in range(2, n + 1):",
      "      I.append(s.MOD - I[s.MOD % i] * (s.MOD // i) % s.MOD)",
      "    return I",
      "",
      "# ラグ何とか補間 f(x) = y の値からf(T)を求める",
      "def ragu1(x, y, T):",
      "  n = len(x) - 1",
      "  ret = 0",
      "  for i in range(n + 1):",
      "    t = 1",
      "    for j in range(n + 1):",
      "      if i == j: continue",
      "      t *= T - x[j]",
      "      t *= inv.invx(x[i] - x[j])",
      "      t %= MOD",
      "    ret += t * y[i]",
      "    ret %= MOD",
      "  return ret",
      "",
      "# ラグ何とか補間 f(x) = y の値からx^kの係数リストを求める",
      "def ragu2(x, yy):",
      "  y = [yy[i] for i in range(len(yy))]",
      "  n = len(x) - 1",
      "  for i in range(n + 1):",
      "    t = 1",
      "    for j in range(n + 1):",
      "      if i != j: t *= x[i] - x[j]",
      "    t %= MOD",
      "    y[i] *= inv.invx(t)",
      "    y[i] %= MOD",
      "",
      "  cur = 0",
      "  nxt = 1",
      "  dp = [[0] * (n + 2) for _ in range(2)]",
      "  dp[0][0] = -1 * x[0]",
      "  dp[0][1] = 1",
      "  for i in range(1, n + 1):",
      "    for j in range(n + 2):",
      "      dp[nxt][j] = dp[cur][j] * -1 * x[i]",
      "      if j >= 1: dp[nxt][j] += dp[cur][j - 1]",
      "    nxt, cur = cur, nxt",
      "  xinv = inv.invL(len(x))",
      "  ret = [0] * (n + 1)",
      "  for i in range(n + 1):",
      "    if y[i] == 0: continue",
      "    if x[i] == 0:",
      "      for j in range(n + 1): ret[j] += dp[cur][j + 1] * y[i]",
      "    else:",
      "      ret[0] -= dp[cur][0] * xinv[i] * y[i] % MOD",
      "      ret[0] %= MOD",
      "      pre = -1 * dp[cur][0] * xinv[i] % MOD",
      "      for j in range(1, n + 1):",
      "        ret[j] -= (dp[cur][j] - pre) * xinv[i] * y[i] % MOD",
      "        pre = -1 * (dp[cur][j] - pre) * xinv[i] % MOD",
      "        ret[j] %= MOD",
      "  return ret",
      "",
      "x = [0, 1, 2, 3]",
      "y = [1, 3, 5, 7]",
      "",
      "MOD = 998244353",
      "inv = Inv(MOD)",
      ""
    ],
    "description": "ラグなんとか補間",
    "scope": "python"
  },
  "multiset": {
    "prefix": "multiset",
    "body": [
      "import heapq",
      "pop = heapq.heappop",
      "push = heapq.heappush",
      "class multiset:",
      "  def __init__(s, isMinMax):",
      "    # min:1 max:2 minmax:3",
      "    s.mi = isMinMax & 1",
      "    s.ma = isMinMax >> 1",
      "    s.miq = []",
      "    s.maq = []",
      "    s.R = {}",
      "  def insert(s, v):",
      "    if v in s.R: s.R[v] += 1",
      "    else: s.R[v] = 1",
      "    if s.mi: push(s.miq, v)",
      "    if s.ma: push(s.maq, -v)",
      "  def delete(s, v):",
      "    if v in s.R: s.R[v] = max(0, s.R[v] - 1)",
      "    if s.ma:",
      "      while s.maq:",
      "        if s.R[-s.maq[0]] == 0: pop(s.maq)",
      "        else: break",
      "    if s.mi:",
      "      while s.miq:",
      "        if s.R[s.miq[0]] == 0: pop(s.miq)",
      "        else: break",
      "  def getMax(s):",
      "    if s.maq: return -s.maq[0]",
      "    else: return None",
      "  def getMin(s):",
      "    if s.miq: return s.miq[0]",
      "    else: return None",
      ""
    ],
    "description": "マルチセット",
    "scope": "python"
  },
  "linkedlist": {
    "prefix": "linkedlist",
    "body": [
      "# 連結リスト add/insertとremoveをO(1)",
      "class DoubleLinkedList():",
      "  class Node():",
      "    def __init__(s, data, previous=None, next=None):",
      "      s.data = data",
      "      s.previous = previous",
      "      s.next = next",
      "",
      "  def __init__(s):",
      "    s._head = s.Node('DUMMY-HEAD')",
      "    s._tail = s.Node('DUMMY-TAIL', previous=s._head)",
      "    s._head.next = s._tail",
      "    s.length = 0",
      "    s.Nodes = {}",
      "",
      "  # リストを設定",
      "  def setList(s, data):",
      "    for a in data:",
      "      s.add(a)",
      "",
      "  # データを末尾に連結O(1)",
      "  def add(s, data):",
      "    node = s.Node(data, previous=s._tail.previous, next=s._tail)",
      "    s._tail.previous.next = node",
      "    s._tail.previous = node",
      "    s.length += 1",
      "    s.Nodes[data] = node",
      "",
      "  # データを削除O(1)",
      "  def remove(s, data):",
      "    target = s.Nodes[data]",
      "    target.previous.next = target.next",
      "    target.next.previous = target.previous",
      "    del target",
      "    s.length -= 1",
      "",
      "  # data_iの後にdataを追加 O(1)",
      "  def insert(s, deta_i, data):",
      "    target = s.Nodes[deta_i]",
      "    node = s.Node(data, previous=target, next=target.next)",
      "    target.next.previous = node",
      "    target.next = node",
      "    s.length += 1",
      "    s.Nodes[data] = node",
      "",
      "  # リスト取得",
      "  def getList(s):",
      "    return s.list",
      "       ",
      "  def pophead(s):",
      "    target = s._head.next",
      "    if target == s._tail:",
      "      return None",
      "    s._head.next = target.next",
      "    target.next.previous = s._head",
      "    data = target.data",
      "    s.length -= 1",
      "    del target",
      "    return data",
      "",
      "  def poptail(s):",
      "    target = s._tail.previous",
      "    if target == s._head:",
      "      return None",
      "    s._tail.previous = target.previous",
      "    target.previous.next = s._tail",
      "    data = target.data",
      "    s.length -= 1",
      "    del target",
      "    return data",
      "",
      "  def print_reverse(s):",
      "    node = s._tail.previous",
      "    while node != s._head:",
      "      print(node.drata)",
      "      node = node.pevious",
      "",
      "  @property",
      "  def list(s):",
      "    node_data = []",
      "    node = s._head.next",
      "    while node != s._tail:",
      "      node_data.append(node.data)",
      "      node = node.next",
      "    return node_data",
      "",
      "  def __iter__(s):",
      "    node_data = s.list",
      "    return iter(node_data)",
      ""
    ],
    "description": "連結リスト add/insertとremoveをO(1)",
    "scope": "python"
  },
  "sorted": {
    "prefix": "sort",
    "body": [
      "from functools import cmp_to_key",
      "def cmpstr(a, b):",
      "    ret = a < b",
      "    return ret",
      "arr = [i for i in range(10)]",
      "arr = sorted(arr, key=cmp_to_key(cmpstr))"
    ],
    "description": "比較関数",
    "scope": "python"
  },
  "abc": {
    "prefix": "abc",
    "body": [
      "ABC = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\""
    ],
    "description": "アルファベットの一覧",
    "scope": "python"
  },
  "trie": {
    "scope": "python",
    "prefix": "trie",
    "description": "文字列の集合を木構造として表す",
    "body": [
      "class Trie:",
      "  def __init__(s):",
      "    s.root = s.Node()",
      "",
      "  class Node:",
      "    def __init__(s):",
      "      s.Son = {}",
      "      s.value = 0",
      "  ",
      "  # 文字列を追加 key: 文字のリスト, valuse : 文字列の値",
      "  def insert(s, key, value):",
      "    node = s.root",
      "    for c in key:",
      "      if c not in node.Son:",
      "        node.Son[c] = s.Node()",
      "      node = node.Son[c]",
      "    node.value = value",
      "",
      "  # 文字列を検索",
      "  def find(s, key):",
      "    node = s.root",
      "    for c in key:",
      "      if c not in node.Son:",
      "        return False",
      "      node = node.Son[c]",
      "    return node.value"
    ]
  },
  "unionFindPotensial": {
    "prefix": "unionFindPotensial",
    "body": [
      "class UnionPotential:",
      "  def __init__(s, num):",
      "    s.T = [-1] * num",
      "    s.W = [0] * num",
      "",
      "  def root(s, x):",
      "    if s.T[x] < 0: return x",
      "    t = s.root(s.T[x])",
      "    s.W[x] += s.W[s.T[x]]",
      "    s.T[x] = t",
      "    return t",
      "",
      "  def merge(s, x, y, w):",
      "    an, bn = s.root(x), s.root(y)",
      "    if an == bn: return False",
      "    am, bm = -s.T[an], -s.T[bn]",
      "    aw, bw = s.weight(x), s.weight(y)",
      "    w += aw - bw",
      "    if am < bm: an, bn, w = bn, an, -w",
      "    s.T[an] += s.T[bn]",
      "    s.T[bn], s.W[bn] = an, w",
      "    return True",
      "",
      "  def size(s, x):",
      "    n = s.root(x)",
      "    return -s.T[n]",
      "",
      "  def same(s, x, y):",
      "    return s.root(x) == s.root(y)",
      "  ",
      "  def diff(s, x, y):",
      "    return s.weight(y) - s.weight(x)",
      "  ",
      "  def weight(s, x):",
      "    s.root(x)",
      "    return s.W[x]",
      "",
      "  def print(s): #デバッグ用",
      "    ans = []",
      "    for i in range(len(s.T)):",
      "      ans.append(s.root(i))",
      "    print(\"parent\\t: \", *s.T, sep = \"\\t\")",
      "    print(\"potential: \", *s.W, sep = \"\\t\")",
      "    print(\"root\\t: \", *ans, sep = \"\\t\")",
      ""
    ],
    "description": "ポテンシャル付きUnionFind",
    "scope": "python"
  }
}